// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: document.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#if CAPNP_VERSION != 9001
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(f638d18cb9d8f2fd);
CAPNP_DECLARE_SCHEMA(b9fec0afa09d2253);
CAPNP_DECLARE_SCHEMA(807bfcbdaa351b91);
CAPNP_DECLARE_SCHEMA(851e4f52598f1e94);
CAPNP_DECLARE_SCHEMA(84edce2a246ba21e);
CAPNP_DECLARE_SCHEMA(ea4dcf6fcffaec80);
CAPNP_DECLARE_SCHEMA(b6b53975f04d0698);
CAPNP_DECLARE_SCHEMA(f2f1da158debde88);
CAPNP_DECLARE_SCHEMA(eff9dfc63ecfab63);
CAPNP_DECLARE_SCHEMA(f3626db692c3e9df);
CAPNP_DECLARE_SCHEMA(e9bfcd5dae76e2b5);
CAPNP_DECLARE_SCHEMA(e78f975f863e0853);
CAPNP_DECLARE_SCHEMA(cffbc472e0f2ff20);
CAPNP_DECLARE_SCHEMA(c1dabd63a0b671dd);
CAPNP_DECLARE_SCHEMA(e0a81db883371cec);
CAPNP_DECLARE_SCHEMA(90a6dcb426a2f466);
CAPNP_DECLARE_SCHEMA(d865c2f3ce83f894);
CAPNP_DECLARE_SCHEMA(8dc3992ae107d7db);
CAPNP_DECLARE_SCHEMA(b294b061e6cb1894);
CAPNP_DECLARE_SCHEMA(835a01387cde4b67);
CAPNP_DECLARE_SCHEMA(f06ac8d5ce2bedf4);
CAPNP_DECLARE_SCHEMA(83a993bc64da75a1);
CAPNP_DECLARE_SCHEMA(b79be6fd6b53c23a);
enum class AccidentalMode_b79be6fd6b53c23a: uint16_t {
  SHARP,
  FLAT,
};
CAPNP_DECLARE_ENUM(AccidentalMode, b79be6fd6b53c23a);
CAPNP_DECLARE_SCHEMA(a8a856289ab511b0);
enum class ChipKind_a8a856289ab511b0: uint16_t {
  UNKNOWN,
  SPC700,
};
CAPNP_DECLARE_ENUM(ChipKind, a8a856289ab511b0);
CAPNP_DECLARE_SCHEMA(c011ae832de79b57);
CAPNP_DECLARE_SCHEMA(ebd00718fee78c30);

}  // namespace schemas
}  // namespace capnp

namespace serialize {
namespace generated {

extern const ::capnp::_::ConstData<8> MAGIC_NUMBER;
struct Versions {
  Versions() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  static constexpr  ::uint32_t UNKNOWN = 0u;
  static constexpr  ::uint32_t MINIMUM = 2u;
  static constexpr  ::uint32_t CURRENT = 2u;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b9fec0afa09d2253, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct MaybeEffect {
  MaybeEffect() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ea4dcf6fcffaec80, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TimedRowEvent {
  TimedRowEvent() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Note;
  struct Instr;
  struct Volume;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b6b53975f04d0698, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TimedRowEvent::Note {
  Note() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    NONE,
    SOME,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f2f1da158debde88, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TimedRowEvent::Instr {
  Instr() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    NONE,
    SOME,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(eff9dfc63ecfab63, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TimedRowEvent::Volume {
  Volume() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    NONE,
    SOME,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f3626db692c3e9df, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Pattern {
  Pattern() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e9bfcd5dae76e2b5, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TimelineBlock {
  TimelineBlock() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e78f975f863e0853, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TimelineCell {
  TimelineCell() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cffbc472e0f2ff20, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TimelineFrame {
  TimelineFrame() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c1dabd63a0b671dd, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SampleTuning {
  SampleTuning() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e0a81db883371cec, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct MaybeSample {
  MaybeSample() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    NONE,
    SOME,
  };
  struct Some;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(90a6dcb426a2f466, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct MaybeSample::Some {
  Some() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d865c2f3ce83f894, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Adsr {
  Adsr() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8dc3992ae107d7db, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct InstrumentPatch {
  InstrumentPatch() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b294b061e6cb1894, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct MaybeInstrument {
  MaybeInstrument() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    NONE,
    SOME,
  };
  struct Some;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(835a01387cde4b67, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct MaybeInstrument::Some {
  Some() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f06ac8d5ce2bedf4, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SequencerOptions {
  SequencerOptions() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(83a993bc64da75a1, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

typedef ::capnp::schemas::AccidentalMode_b79be6fd6b53c23a AccidentalMode;

typedef ::capnp::schemas::ChipKind_a8a856289ab511b0 ChipKind;

struct PerChannelSettings {
  PerChannelSettings() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c011ae832de79b57, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Document {
  Document() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ebd00718fee78c30, 2, 7)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Versions::Reader {
public:
  typedef Versions Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Versions::Builder {
public:
  typedef Versions Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Versions::Pipeline {
public:
  typedef Versions Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MaybeEffect::Reader {
public:
  typedef MaybeEffect Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getName0() const;

  inline  ::uint8_t getName1() const;

  inline  ::uint8_t getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MaybeEffect::Builder {
public:
  typedef MaybeEffect Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getName0();
  inline void setName0( ::uint8_t value);

  inline  ::uint8_t getName1();
  inline void setName1( ::uint8_t value);

  inline  ::uint8_t getValue();
  inline void setValue( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MaybeEffect::Pipeline {
public:
  typedef MaybeEffect Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TimedRowEvent::Reader {
public:
  typedef TimedRowEvent Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getAnchorBeatNum() const;

  inline  ::int32_t getAnchorBeatDen() const;

  inline typename Note::Reader getNote() const;

  inline typename Instr::Reader getInstr() const;

  inline typename Volume::Reader getVolume() const;

  inline bool hasEffects() const;
  inline  ::capnp::List< ::serialize::generated::MaybeEffect,  ::capnp::Kind::STRUCT>::Reader getEffects() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TimedRowEvent::Builder {
public:
  typedef TimedRowEvent Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getAnchorBeatNum();
  inline void setAnchorBeatNum( ::int32_t value);

  inline  ::int32_t getAnchorBeatDen();
  inline void setAnchorBeatDen( ::int32_t value);

  inline typename Note::Builder getNote();
  inline typename Note::Builder initNote();

  inline typename Instr::Builder getInstr();
  inline typename Instr::Builder initInstr();

  inline typename Volume::Builder getVolume();
  inline typename Volume::Builder initVolume();

  inline bool hasEffects();
  inline  ::capnp::List< ::serialize::generated::MaybeEffect,  ::capnp::Kind::STRUCT>::Builder getEffects();
  inline void setEffects( ::capnp::List< ::serialize::generated::MaybeEffect,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::serialize::generated::MaybeEffect,  ::capnp::Kind::STRUCT>::Builder initEffects(unsigned int size);
  inline void adoptEffects(::capnp::Orphan< ::capnp::List< ::serialize::generated::MaybeEffect,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::serialize::generated::MaybeEffect,  ::capnp::Kind::STRUCT>> disownEffects();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TimedRowEvent::Pipeline {
public:
  typedef TimedRowEvent Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename Note::Pipeline getNote();
  inline typename Instr::Pipeline getInstr();
  inline typename Volume::Pipeline getVolume();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TimedRowEvent::Note::Reader {
public:
  typedef Note Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isNone() const;
  inline  ::capnp::Void getNone() const;

  inline bool isSome() const;
  inline  ::int16_t getSome() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TimedRowEvent::Note::Builder {
public:
  typedef Note Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isNone();
  inline  ::capnp::Void getNone();
  inline void setNone( ::capnp::Void value = ::capnp::VOID);

  inline bool isSome();
  inline  ::int16_t getSome();
  inline void setSome( ::int16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TimedRowEvent::Note::Pipeline {
public:
  typedef Note Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TimedRowEvent::Instr::Reader {
public:
  typedef Instr Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isNone() const;
  inline  ::capnp::Void getNone() const;

  inline bool isSome() const;
  inline  ::uint8_t getSome() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TimedRowEvent::Instr::Builder {
public:
  typedef Instr Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isNone();
  inline  ::capnp::Void getNone();
  inline void setNone( ::capnp::Void value = ::capnp::VOID);

  inline bool isSome();
  inline  ::uint8_t getSome();
  inline void setSome( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TimedRowEvent::Instr::Pipeline {
public:
  typedef Instr Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TimedRowEvent::Volume::Reader {
public:
  typedef Volume Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isNone() const;
  inline  ::capnp::Void getNone() const;

  inline bool isSome() const;
  inline  ::uint8_t getSome() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TimedRowEvent::Volume::Builder {
public:
  typedef Volume Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isNone();
  inline  ::capnp::Void getNone();
  inline void setNone( ::capnp::Void value = ::capnp::VOID);

  inline bool isSome();
  inline  ::uint8_t getSome();
  inline void setSome( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TimedRowEvent::Volume::Pipeline {
public:
  typedef Volume Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Pattern::Reader {
public:
  typedef Pattern Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasEvents() const;
  inline  ::capnp::List< ::serialize::generated::TimedRowEvent,  ::capnp::Kind::STRUCT>::Reader getEvents() const;

  inline  ::uint32_t getLoopLength() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Pattern::Builder {
public:
  typedef Pattern Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasEvents();
  inline  ::capnp::List< ::serialize::generated::TimedRowEvent,  ::capnp::Kind::STRUCT>::Builder getEvents();
  inline void setEvents( ::capnp::List< ::serialize::generated::TimedRowEvent,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::serialize::generated::TimedRowEvent,  ::capnp::Kind::STRUCT>::Builder initEvents(unsigned int size);
  inline void adoptEvents(::capnp::Orphan< ::capnp::List< ::serialize::generated::TimedRowEvent,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::serialize::generated::TimedRowEvent,  ::capnp::Kind::STRUCT>> disownEvents();

  inline  ::uint32_t getLoopLength();
  inline void setLoopLength( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Pattern::Pipeline {
public:
  typedef Pattern Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TimelineBlock::Reader {
public:
  typedef TimelineBlock Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getBeginTime() const;

  inline  ::uint32_t getEndTime() const;

  inline bool hasPattern() const;
  inline  ::serialize::generated::Pattern::Reader getPattern() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TimelineBlock::Builder {
public:
  typedef TimelineBlock Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getBeginTime();
  inline void setBeginTime( ::int32_t value);

  inline  ::uint32_t getEndTime();
  inline void setEndTime( ::uint32_t value);

  inline bool hasPattern();
  inline  ::serialize::generated::Pattern::Builder getPattern();
  inline void setPattern( ::serialize::generated::Pattern::Reader value);
  inline  ::serialize::generated::Pattern::Builder initPattern();
  inline void adoptPattern(::capnp::Orphan< ::serialize::generated::Pattern>&& value);
  inline ::capnp::Orphan< ::serialize::generated::Pattern> disownPattern();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TimelineBlock::Pipeline {
public:
  typedef TimelineBlock Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::serialize::generated::Pattern::Pipeline getPattern();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TimelineCell::Reader {
public:
  typedef TimelineCell Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasBlocks() const;
  inline  ::capnp::List< ::serialize::generated::TimelineBlock,  ::capnp::Kind::STRUCT>::Reader getBlocks() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TimelineCell::Builder {
public:
  typedef TimelineCell Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBlocks();
  inline  ::capnp::List< ::serialize::generated::TimelineBlock,  ::capnp::Kind::STRUCT>::Builder getBlocks();
  inline void setBlocks( ::capnp::List< ::serialize::generated::TimelineBlock,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::serialize::generated::TimelineBlock,  ::capnp::Kind::STRUCT>::Builder initBlocks(unsigned int size);
  inline void adoptBlocks(::capnp::Orphan< ::capnp::List< ::serialize::generated::TimelineBlock,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::serialize::generated::TimelineBlock,  ::capnp::Kind::STRUCT>> disownBlocks();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TimelineCell::Pipeline {
public:
  typedef TimelineCell Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TimelineFrame::Reader {
public:
  typedef TimelineFrame Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getNbeatsNum() const;

  inline  ::uint32_t getNbeatsDen() const;

  inline bool hasChipChannelCells() const;
  inline  ::capnp::List< ::capnp::List< ::serialize::generated::TimelineCell,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>::Reader getChipChannelCells() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TimelineFrame::Builder {
public:
  typedef TimelineFrame Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getNbeatsNum();
  inline void setNbeatsNum( ::uint32_t value);

  inline  ::uint32_t getNbeatsDen();
  inline void setNbeatsDen( ::uint32_t value);

  inline bool hasChipChannelCells();
  inline  ::capnp::List< ::capnp::List< ::serialize::generated::TimelineCell,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>::Builder getChipChannelCells();
  inline void setChipChannelCells( ::capnp::List< ::capnp::List< ::serialize::generated::TimelineCell,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>::Reader value);
  inline void setChipChannelCells(::kj::ArrayPtr<const  ::capnp::List< ::serialize::generated::TimelineCell,  ::capnp::Kind::STRUCT>::Reader> value);
  inline  ::capnp::List< ::capnp::List< ::serialize::generated::TimelineCell,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>::Builder initChipChannelCells(unsigned int size);
  inline void adoptChipChannelCells(::capnp::Orphan< ::capnp::List< ::capnp::List< ::serialize::generated::TimelineCell,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::List< ::serialize::generated::TimelineCell,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>> disownChipChannelCells();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TimelineFrame::Pipeline {
public:
  typedef TimelineFrame Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SampleTuning::Reader {
public:
  typedef SampleTuning Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getSampleRate() const;

  inline  ::uint8_t getRootKey() const;

  inline  ::int16_t getDetuneCents() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SampleTuning::Builder {
public:
  typedef SampleTuning Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getSampleRate();
  inline void setSampleRate( ::uint32_t value);

  inline  ::uint8_t getRootKey();
  inline void setRootKey( ::uint8_t value);

  inline  ::int16_t getDetuneCents();
  inline void setDetuneCents( ::int16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SampleTuning::Pipeline {
public:
  typedef SampleTuning Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MaybeSample::Reader {
public:
  typedef MaybeSample Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isNone() const;
  inline  ::capnp::Void getNone() const;

  inline bool isSome() const;
  inline typename Some::Reader getSome() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MaybeSample::Builder {
public:
  typedef MaybeSample Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isNone();
  inline  ::capnp::Void getNone();
  inline void setNone( ::capnp::Void value = ::capnp::VOID);

  inline bool isSome();
  inline typename Some::Builder getSome();
  inline typename Some::Builder initSome();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MaybeSample::Pipeline {
public:
  typedef MaybeSample Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MaybeSample::Some::Reader {
public:
  typedef Some Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasBrr() const;
  inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Reader getBrr() const;

  inline  ::uint16_t getLoopByte() const;

  inline bool hasTuning() const;
  inline  ::serialize::generated::SampleTuning::Reader getTuning() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MaybeSample::Some::Builder {
public:
  typedef Some Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasBrr();
  inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Builder getBrr();
  inline void setBrr( ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setBrr(::kj::ArrayPtr<const  ::uint8_t> value);
  inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Builder initBrr(unsigned int size);
  inline void adoptBrr(::capnp::Orphan< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>> disownBrr();

  inline  ::uint16_t getLoopByte();
  inline void setLoopByte( ::uint16_t value);

  inline bool hasTuning();
  inline  ::serialize::generated::SampleTuning::Builder getTuning();
  inline void setTuning( ::serialize::generated::SampleTuning::Reader value);
  inline  ::serialize::generated::SampleTuning::Builder initTuning();
  inline void adoptTuning(::capnp::Orphan< ::serialize::generated::SampleTuning>&& value);
  inline ::capnp::Orphan< ::serialize::generated::SampleTuning> disownTuning();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MaybeSample::Some::Pipeline {
public:
  typedef Some Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::serialize::generated::SampleTuning::Pipeline getTuning();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Adsr::Reader {
public:
  typedef Adsr Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getAttack() const;

  inline  ::uint8_t getDecay() const;

  inline  ::uint8_t getSustain() const;

  inline  ::uint8_t getRelease() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Adsr::Builder {
public:
  typedef Adsr Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getAttack();
  inline void setAttack( ::uint8_t value);

  inline  ::uint8_t getDecay();
  inline void setDecay( ::uint8_t value);

  inline  ::uint8_t getSustain();
  inline void setSustain( ::uint8_t value);

  inline  ::uint8_t getRelease();
  inline void setRelease( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Adsr::Pipeline {
public:
  typedef Adsr Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class InstrumentPatch::Reader {
public:
  typedef InstrumentPatch Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getMinNote() const;

  inline  ::uint8_t getSampleIdx() const;

  inline bool hasAdsr() const;
  inline  ::serialize::generated::Adsr::Reader getAdsr() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class InstrumentPatch::Builder {
public:
  typedef InstrumentPatch Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getMinNote();
  inline void setMinNote( ::uint8_t value);

  inline  ::uint8_t getSampleIdx();
  inline void setSampleIdx( ::uint8_t value);

  inline bool hasAdsr();
  inline  ::serialize::generated::Adsr::Builder getAdsr();
  inline void setAdsr( ::serialize::generated::Adsr::Reader value);
  inline  ::serialize::generated::Adsr::Builder initAdsr();
  inline void adoptAdsr(::capnp::Orphan< ::serialize::generated::Adsr>&& value);
  inline ::capnp::Orphan< ::serialize::generated::Adsr> disownAdsr();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class InstrumentPatch::Pipeline {
public:
  typedef InstrumentPatch Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::serialize::generated::Adsr::Pipeline getAdsr();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MaybeInstrument::Reader {
public:
  typedef MaybeInstrument Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isNone() const;
  inline  ::capnp::Void getNone() const;

  inline bool isSome() const;
  inline typename Some::Reader getSome() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MaybeInstrument::Builder {
public:
  typedef MaybeInstrument Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isNone();
  inline  ::capnp::Void getNone();
  inline void setNone( ::capnp::Void value = ::capnp::VOID);

  inline bool isSome();
  inline typename Some::Builder getSome();
  inline typename Some::Builder initSome();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MaybeInstrument::Pipeline {
public:
  typedef MaybeInstrument Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MaybeInstrument::Some::Reader {
public:
  typedef Some Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasKeysplit() const;
  inline  ::capnp::List< ::serialize::generated::InstrumentPatch,  ::capnp::Kind::STRUCT>::Reader getKeysplit() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MaybeInstrument::Some::Builder {
public:
  typedef Some Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasKeysplit();
  inline  ::capnp::List< ::serialize::generated::InstrumentPatch,  ::capnp::Kind::STRUCT>::Builder getKeysplit();
  inline void setKeysplit( ::capnp::List< ::serialize::generated::InstrumentPatch,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::serialize::generated::InstrumentPatch,  ::capnp::Kind::STRUCT>::Builder initKeysplit(unsigned int size);
  inline void adoptKeysplit(::capnp::Orphan< ::capnp::List< ::serialize::generated::InstrumentPatch,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::serialize::generated::InstrumentPatch,  ::capnp::Kind::STRUCT>> disownKeysplit();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MaybeInstrument::Some::Pipeline {
public:
  typedef Some Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SequencerOptions::Reader {
public:
  typedef SequencerOptions Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline double getTargetTempo() const;

  inline  ::uint32_t getSpcTimerPeriod() const;

  inline  ::uint32_t getTicksPerBeat() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SequencerOptions::Builder {
public:
  typedef SequencerOptions Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getTargetTempo();
  inline void setTargetTempo(double value);

  inline  ::uint32_t getSpcTimerPeriod();
  inline void setSpcTimerPeriod( ::uint32_t value);

  inline  ::uint32_t getTicksPerBeat();
  inline void setTicksPerBeat( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SequencerOptions::Pipeline {
public:
  typedef SequencerOptions Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PerChannelSettings::Reader {
public:
  typedef PerChannelSettings Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getNEffectCol() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PerChannelSettings::Builder {
public:
  typedef PerChannelSettings Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getNEffectCol();
  inline void setNEffectCol( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PerChannelSettings::Pipeline {
public:
  typedef PerChannelSettings Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Document::Reader {
public:
  typedef Document Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVersion() const;

  inline bool hasSequencerOptions() const;
  inline  ::serialize::generated::SequencerOptions::Reader getSequencerOptions() const;

  inline bool hasFrequencyTable() const;
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader getFrequencyTable() const;

  inline  ::serialize::generated::AccidentalMode getAccidentalMode() const;

  inline  ::uint16_t getZoomLevel() const;

  inline  ::uint8_t getEffectNameChars() const;

  inline bool hasSamples() const;
  inline  ::capnp::List< ::serialize::generated::MaybeSample,  ::capnp::Kind::STRUCT>::Reader getSamples() const;

  inline bool hasInstruments() const;
  inline  ::capnp::List< ::serialize::generated::MaybeInstrument,  ::capnp::Kind::STRUCT>::Reader getInstruments() const;

  inline bool hasChips() const;
  inline  ::capnp::List< ::serialize::generated::ChipKind,  ::capnp::Kind::ENUM>::Reader getChips() const;

  inline bool hasChipChannelSettings() const;
  inline  ::capnp::List< ::capnp::List< ::serialize::generated::PerChannelSettings,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>::Reader getChipChannelSettings() const;

  inline bool hasTimeline() const;
  inline  ::capnp::List< ::serialize::generated::TimelineFrame,  ::capnp::Kind::STRUCT>::Reader getTimeline() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Document::Builder {
public:
  typedef Document Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVersion();
  inline void setVersion( ::uint32_t value);

  inline bool hasSequencerOptions();
  inline  ::serialize::generated::SequencerOptions::Builder getSequencerOptions();
  inline void setSequencerOptions( ::serialize::generated::SequencerOptions::Reader value);
  inline  ::serialize::generated::SequencerOptions::Builder initSequencerOptions();
  inline void adoptSequencerOptions(::capnp::Orphan< ::serialize::generated::SequencerOptions>&& value);
  inline ::capnp::Orphan< ::serialize::generated::SequencerOptions> disownSequencerOptions();

  inline bool hasFrequencyTable();
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder getFrequencyTable();
  inline void setFrequencyTable( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setFrequencyTable(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder initFrequencyTable(unsigned int size);
  inline void adoptFrequencyTable(::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> disownFrequencyTable();

  inline  ::serialize::generated::AccidentalMode getAccidentalMode();
  inline void setAccidentalMode( ::serialize::generated::AccidentalMode value);

  inline  ::uint16_t getZoomLevel();
  inline void setZoomLevel( ::uint16_t value);

  inline  ::uint8_t getEffectNameChars();
  inline void setEffectNameChars( ::uint8_t value);

  inline bool hasSamples();
  inline  ::capnp::List< ::serialize::generated::MaybeSample,  ::capnp::Kind::STRUCT>::Builder getSamples();
  inline void setSamples( ::capnp::List< ::serialize::generated::MaybeSample,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::serialize::generated::MaybeSample,  ::capnp::Kind::STRUCT>::Builder initSamples(unsigned int size);
  inline void adoptSamples(::capnp::Orphan< ::capnp::List< ::serialize::generated::MaybeSample,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::serialize::generated::MaybeSample,  ::capnp::Kind::STRUCT>> disownSamples();

  inline bool hasInstruments();
  inline  ::capnp::List< ::serialize::generated::MaybeInstrument,  ::capnp::Kind::STRUCT>::Builder getInstruments();
  inline void setInstruments( ::capnp::List< ::serialize::generated::MaybeInstrument,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::serialize::generated::MaybeInstrument,  ::capnp::Kind::STRUCT>::Builder initInstruments(unsigned int size);
  inline void adoptInstruments(::capnp::Orphan< ::capnp::List< ::serialize::generated::MaybeInstrument,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::serialize::generated::MaybeInstrument,  ::capnp::Kind::STRUCT>> disownInstruments();

  inline bool hasChips();
  inline  ::capnp::List< ::serialize::generated::ChipKind,  ::capnp::Kind::ENUM>::Builder getChips();
  inline void setChips( ::capnp::List< ::serialize::generated::ChipKind,  ::capnp::Kind::ENUM>::Reader value);
  inline void setChips(::kj::ArrayPtr<const  ::serialize::generated::ChipKind> value);
  inline  ::capnp::List< ::serialize::generated::ChipKind,  ::capnp::Kind::ENUM>::Builder initChips(unsigned int size);
  inline void adoptChips(::capnp::Orphan< ::capnp::List< ::serialize::generated::ChipKind,  ::capnp::Kind::ENUM>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::serialize::generated::ChipKind,  ::capnp::Kind::ENUM>> disownChips();

  inline bool hasChipChannelSettings();
  inline  ::capnp::List< ::capnp::List< ::serialize::generated::PerChannelSettings,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>::Builder getChipChannelSettings();
  inline void setChipChannelSettings( ::capnp::List< ::capnp::List< ::serialize::generated::PerChannelSettings,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>::Reader value);
  inline void setChipChannelSettings(::kj::ArrayPtr<const  ::capnp::List< ::serialize::generated::PerChannelSettings,  ::capnp::Kind::STRUCT>::Reader> value);
  inline  ::capnp::List< ::capnp::List< ::serialize::generated::PerChannelSettings,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>::Builder initChipChannelSettings(unsigned int size);
  inline void adoptChipChannelSettings(::capnp::Orphan< ::capnp::List< ::capnp::List< ::serialize::generated::PerChannelSettings,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::List< ::serialize::generated::PerChannelSettings,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>> disownChipChannelSettings();

  inline bool hasTimeline();
  inline  ::capnp::List< ::serialize::generated::TimelineFrame,  ::capnp::Kind::STRUCT>::Builder getTimeline();
  inline void setTimeline( ::capnp::List< ::serialize::generated::TimelineFrame,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::serialize::generated::TimelineFrame,  ::capnp::Kind::STRUCT>::Builder initTimeline(unsigned int size);
  inline void adoptTimeline(::capnp::Orphan< ::capnp::List< ::serialize::generated::TimelineFrame,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::serialize::generated::TimelineFrame,  ::capnp::Kind::STRUCT>> disownTimeline();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Document::Pipeline {
public:
  typedef Document Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::serialize::generated::SequencerOptions::Pipeline getSequencerOptions();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::uint8_t MaybeEffect::Reader::getName0() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t MaybeEffect::Builder::getName0() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void MaybeEffect::Builder::setName0( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t MaybeEffect::Reader::getName1() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t MaybeEffect::Builder::getName1() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void MaybeEffect::Builder::setName1( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t MaybeEffect::Reader::getValue() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t MaybeEffect::Builder::getValue() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void MaybeEffect::Builder::setValue( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t TimedRowEvent::Reader::getAnchorBeatNum() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t TimedRowEvent::Builder::getAnchorBeatNum() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TimedRowEvent::Builder::setAnchorBeatNum( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t TimedRowEvent::Reader::getAnchorBeatDen() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t TimedRowEvent::Builder::getAnchorBeatDen() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TimedRowEvent::Builder::setAnchorBeatDen( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline typename TimedRowEvent::Note::Reader TimedRowEvent::Reader::getNote() const {
  return typename TimedRowEvent::Note::Reader(_reader);
}
inline typename TimedRowEvent::Note::Builder TimedRowEvent::Builder::getNote() {
  return typename TimedRowEvent::Note::Builder(_builder);
}
#if !CAPNP_LITE
inline typename TimedRowEvent::Note::Pipeline TimedRowEvent::Pipeline::getNote() {
  return typename TimedRowEvent::Note::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename TimedRowEvent::Note::Builder TimedRowEvent::Builder::initNote() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<4>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<5>() * ::capnp::ELEMENTS, 0);
  return typename TimedRowEvent::Note::Builder(_builder);
}
inline typename TimedRowEvent::Instr::Reader TimedRowEvent::Reader::getInstr() const {
  return typename TimedRowEvent::Instr::Reader(_reader);
}
inline typename TimedRowEvent::Instr::Builder TimedRowEvent::Builder::getInstr() {
  return typename TimedRowEvent::Instr::Builder(_builder);
}
#if !CAPNP_LITE
inline typename TimedRowEvent::Instr::Pipeline TimedRowEvent::Pipeline::getInstr() {
  return typename TimedRowEvent::Instr::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename TimedRowEvent::Instr::Builder TimedRowEvent::Builder::initInstr() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<6>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint8_t>(::capnp::bounded<14>() * ::capnp::ELEMENTS, 0);
  return typename TimedRowEvent::Instr::Builder(_builder);
}
inline typename TimedRowEvent::Volume::Reader TimedRowEvent::Reader::getVolume() const {
  return typename TimedRowEvent::Volume::Reader(_reader);
}
inline typename TimedRowEvent::Volume::Builder TimedRowEvent::Builder::getVolume() {
  return typename TimedRowEvent::Volume::Builder(_builder);
}
#if !CAPNP_LITE
inline typename TimedRowEvent::Volume::Pipeline TimedRowEvent::Pipeline::getVolume() {
  return typename TimedRowEvent::Volume::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename TimedRowEvent::Volume::Builder TimedRowEvent::Builder::initVolume() {
  _builder.setDataField< ::uint8_t>(::capnp::bounded<15>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<8>() * ::capnp::ELEMENTS, 0);
  return typename TimedRowEvent::Volume::Builder(_builder);
}
inline bool TimedRowEvent::Reader::hasEffects() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TimedRowEvent::Builder::hasEffects() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::serialize::generated::MaybeEffect,  ::capnp::Kind::STRUCT>::Reader TimedRowEvent::Reader::getEffects() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::MaybeEffect,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::serialize::generated::MaybeEffect,  ::capnp::Kind::STRUCT>::Builder TimedRowEvent::Builder::getEffects() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::MaybeEffect,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TimedRowEvent::Builder::setEffects( ::capnp::List< ::serialize::generated::MaybeEffect,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::MaybeEffect,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::serialize::generated::MaybeEffect,  ::capnp::Kind::STRUCT>::Builder TimedRowEvent::Builder::initEffects(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::MaybeEffect,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TimedRowEvent::Builder::adoptEffects(
    ::capnp::Orphan< ::capnp::List< ::serialize::generated::MaybeEffect,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::MaybeEffect,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::serialize::generated::MaybeEffect,  ::capnp::Kind::STRUCT>> TimedRowEvent::Builder::disownEffects() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::MaybeEffect,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::serialize::generated::TimedRowEvent::Note::Which TimedRowEvent::Note::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline  ::serialize::generated::TimedRowEvent::Note::Which TimedRowEvent::Note::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline bool TimedRowEvent::Note::Reader::isNone() const {
  return which() == TimedRowEvent::Note::NONE;
}
inline bool TimedRowEvent::Note::Builder::isNone() {
  return which() == TimedRowEvent::Note::NONE;
}
inline  ::capnp::Void TimedRowEvent::Note::Reader::getNone() const {
  KJ_IREQUIRE((which() == TimedRowEvent::Note::NONE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void TimedRowEvent::Note::Builder::getNone() {
  KJ_IREQUIRE((which() == TimedRowEvent::Note::NONE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TimedRowEvent::Note::Builder::setNone( ::capnp::Void value) {
  _builder.setDataField<TimedRowEvent::Note::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, TimedRowEvent::Note::NONE);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TimedRowEvent::Note::Reader::isSome() const {
  return which() == TimedRowEvent::Note::SOME;
}
inline bool TimedRowEvent::Note::Builder::isSome() {
  return which() == TimedRowEvent::Note::SOME;
}
inline  ::int16_t TimedRowEvent::Note::Reader::getSome() const {
  KJ_IREQUIRE((which() == TimedRowEvent::Note::SOME),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::int16_t TimedRowEvent::Note::Builder::getSome() {
  KJ_IREQUIRE((which() == TimedRowEvent::Note::SOME),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void TimedRowEvent::Note::Builder::setSome( ::int16_t value) {
  _builder.setDataField<TimedRowEvent::Note::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, TimedRowEvent::Note::SOME);
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline  ::serialize::generated::TimedRowEvent::Instr::Which TimedRowEvent::Instr::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline  ::serialize::generated::TimedRowEvent::Instr::Which TimedRowEvent::Instr::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline bool TimedRowEvent::Instr::Reader::isNone() const {
  return which() == TimedRowEvent::Instr::NONE;
}
inline bool TimedRowEvent::Instr::Builder::isNone() {
  return which() == TimedRowEvent::Instr::NONE;
}
inline  ::capnp::Void TimedRowEvent::Instr::Reader::getNone() const {
  KJ_IREQUIRE((which() == TimedRowEvent::Instr::NONE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void TimedRowEvent::Instr::Builder::getNone() {
  KJ_IREQUIRE((which() == TimedRowEvent::Instr::NONE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TimedRowEvent::Instr::Builder::setNone( ::capnp::Void value) {
  _builder.setDataField<TimedRowEvent::Instr::Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, TimedRowEvent::Instr::NONE);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TimedRowEvent::Instr::Reader::isSome() const {
  return which() == TimedRowEvent::Instr::SOME;
}
inline bool TimedRowEvent::Instr::Builder::isSome() {
  return which() == TimedRowEvent::Instr::SOME;
}
inline  ::uint8_t TimedRowEvent::Instr::Reader::getSome() const {
  KJ_IREQUIRE((which() == TimedRowEvent::Instr::SOME),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<14>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t TimedRowEvent::Instr::Builder::getSome() {
  KJ_IREQUIRE((which() == TimedRowEvent::Instr::SOME),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<14>() * ::capnp::ELEMENTS);
}
inline void TimedRowEvent::Instr::Builder::setSome( ::uint8_t value) {
  _builder.setDataField<TimedRowEvent::Instr::Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, TimedRowEvent::Instr::SOME);
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<14>() * ::capnp::ELEMENTS, value);
}

inline  ::serialize::generated::TimedRowEvent::Volume::Which TimedRowEvent::Volume::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}
inline  ::serialize::generated::TimedRowEvent::Volume::Which TimedRowEvent::Volume::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}

inline bool TimedRowEvent::Volume::Reader::isNone() const {
  return which() == TimedRowEvent::Volume::NONE;
}
inline bool TimedRowEvent::Volume::Builder::isNone() {
  return which() == TimedRowEvent::Volume::NONE;
}
inline  ::capnp::Void TimedRowEvent::Volume::Reader::getNone() const {
  KJ_IREQUIRE((which() == TimedRowEvent::Volume::NONE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void TimedRowEvent::Volume::Builder::getNone() {
  KJ_IREQUIRE((which() == TimedRowEvent::Volume::NONE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TimedRowEvent::Volume::Builder::setNone( ::capnp::Void value) {
  _builder.setDataField<TimedRowEvent::Volume::Which>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, TimedRowEvent::Volume::NONE);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TimedRowEvent::Volume::Reader::isSome() const {
  return which() == TimedRowEvent::Volume::SOME;
}
inline bool TimedRowEvent::Volume::Builder::isSome() {
  return which() == TimedRowEvent::Volume::SOME;
}
inline  ::uint8_t TimedRowEvent::Volume::Reader::getSome() const {
  KJ_IREQUIRE((which() == TimedRowEvent::Volume::SOME),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<15>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t TimedRowEvent::Volume::Builder::getSome() {
  KJ_IREQUIRE((which() == TimedRowEvent::Volume::SOME),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<15>() * ::capnp::ELEMENTS);
}
inline void TimedRowEvent::Volume::Builder::setSome( ::uint8_t value) {
  _builder.setDataField<TimedRowEvent::Volume::Which>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, TimedRowEvent::Volume::SOME);
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<15>() * ::capnp::ELEMENTS, value);
}

inline bool Pattern::Reader::hasEvents() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Pattern::Builder::hasEvents() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::serialize::generated::TimedRowEvent,  ::capnp::Kind::STRUCT>::Reader Pattern::Reader::getEvents() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::TimedRowEvent,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::serialize::generated::TimedRowEvent,  ::capnp::Kind::STRUCT>::Builder Pattern::Builder::getEvents() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::TimedRowEvent,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Pattern::Builder::setEvents( ::capnp::List< ::serialize::generated::TimedRowEvent,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::TimedRowEvent,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::serialize::generated::TimedRowEvent,  ::capnp::Kind::STRUCT>::Builder Pattern::Builder::initEvents(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::TimedRowEvent,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Pattern::Builder::adoptEvents(
    ::capnp::Orphan< ::capnp::List< ::serialize::generated::TimedRowEvent,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::TimedRowEvent,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::serialize::generated::TimedRowEvent,  ::capnp::Kind::STRUCT>> Pattern::Builder::disownEvents() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::TimedRowEvent,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t Pattern::Reader::getLoopLength() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Pattern::Builder::getLoopLength() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Pattern::Builder::setLoopLength( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t TimelineBlock::Reader::getBeginTime() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t TimelineBlock::Builder::getBeginTime() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TimelineBlock::Builder::setBeginTime( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t TimelineBlock::Reader::getEndTime() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TimelineBlock::Builder::getEndTime() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TimelineBlock::Builder::setEndTime( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool TimelineBlock::Reader::hasPattern() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TimelineBlock::Builder::hasPattern() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::serialize::generated::Pattern::Reader TimelineBlock::Reader::getPattern() const {
  return ::capnp::_::PointerHelpers< ::serialize::generated::Pattern>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::serialize::generated::Pattern::Builder TimelineBlock::Builder::getPattern() {
  return ::capnp::_::PointerHelpers< ::serialize::generated::Pattern>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::serialize::generated::Pattern::Pipeline TimelineBlock::Pipeline::getPattern() {
  return  ::serialize::generated::Pattern::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void TimelineBlock::Builder::setPattern( ::serialize::generated::Pattern::Reader value) {
  ::capnp::_::PointerHelpers< ::serialize::generated::Pattern>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::serialize::generated::Pattern::Builder TimelineBlock::Builder::initPattern() {
  return ::capnp::_::PointerHelpers< ::serialize::generated::Pattern>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TimelineBlock::Builder::adoptPattern(
    ::capnp::Orphan< ::serialize::generated::Pattern>&& value) {
  ::capnp::_::PointerHelpers< ::serialize::generated::Pattern>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::serialize::generated::Pattern> TimelineBlock::Builder::disownPattern() {
  return ::capnp::_::PointerHelpers< ::serialize::generated::Pattern>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TimelineCell::Reader::hasBlocks() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TimelineCell::Builder::hasBlocks() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::serialize::generated::TimelineBlock,  ::capnp::Kind::STRUCT>::Reader TimelineCell::Reader::getBlocks() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::TimelineBlock,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::serialize::generated::TimelineBlock,  ::capnp::Kind::STRUCT>::Builder TimelineCell::Builder::getBlocks() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::TimelineBlock,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TimelineCell::Builder::setBlocks( ::capnp::List< ::serialize::generated::TimelineBlock,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::TimelineBlock,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::serialize::generated::TimelineBlock,  ::capnp::Kind::STRUCT>::Builder TimelineCell::Builder::initBlocks(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::TimelineBlock,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TimelineCell::Builder::adoptBlocks(
    ::capnp::Orphan< ::capnp::List< ::serialize::generated::TimelineBlock,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::TimelineBlock,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::serialize::generated::TimelineBlock,  ::capnp::Kind::STRUCT>> TimelineCell::Builder::disownBlocks() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::TimelineBlock,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t TimelineFrame::Reader::getNbeatsNum() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TimelineFrame::Builder::getNbeatsNum() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TimelineFrame::Builder::setNbeatsNum( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t TimelineFrame::Reader::getNbeatsDen() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TimelineFrame::Builder::getNbeatsDen() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TimelineFrame::Builder::setNbeatsDen( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool TimelineFrame::Reader::hasChipChannelCells() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TimelineFrame::Builder::hasChipChannelCells() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::List< ::serialize::generated::TimelineCell,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>::Reader TimelineFrame::Reader::getChipChannelCells() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::serialize::generated::TimelineCell,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::List< ::serialize::generated::TimelineCell,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>::Builder TimelineFrame::Builder::getChipChannelCells() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::serialize::generated::TimelineCell,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TimelineFrame::Builder::setChipChannelCells( ::capnp::List< ::capnp::List< ::serialize::generated::TimelineCell,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::serialize::generated::TimelineCell,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void TimelineFrame::Builder::setChipChannelCells(::kj::ArrayPtr<const  ::capnp::List< ::serialize::generated::TimelineCell,  ::capnp::Kind::STRUCT>::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::serialize::generated::TimelineCell,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::List< ::serialize::generated::TimelineCell,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>::Builder TimelineFrame::Builder::initChipChannelCells(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::serialize::generated::TimelineCell,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TimelineFrame::Builder::adoptChipChannelCells(
    ::capnp::Orphan< ::capnp::List< ::capnp::List< ::serialize::generated::TimelineCell,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::serialize::generated::TimelineCell,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::List< ::serialize::generated::TimelineCell,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>> TimelineFrame::Builder::disownChipChannelCells() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::serialize::generated::TimelineCell,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t SampleTuning::Reader::getSampleRate() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t SampleTuning::Builder::getSampleRate() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void SampleTuning::Builder::setSampleRate( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t SampleTuning::Reader::getRootKey() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t SampleTuning::Builder::getRootKey() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void SampleTuning::Builder::setRootKey( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::int16_t SampleTuning::Reader::getDetuneCents() const {
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::int16_t SampleTuning::Builder::getDetuneCents() {
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void SampleTuning::Builder::setDetuneCents( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::serialize::generated::MaybeSample::Which MaybeSample::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::serialize::generated::MaybeSample::Which MaybeSample::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool MaybeSample::Reader::isNone() const {
  return which() == MaybeSample::NONE;
}
inline bool MaybeSample::Builder::isNone() {
  return which() == MaybeSample::NONE;
}
inline  ::capnp::Void MaybeSample::Reader::getNone() const {
  KJ_IREQUIRE((which() == MaybeSample::NONE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void MaybeSample::Builder::getNone() {
  KJ_IREQUIRE((which() == MaybeSample::NONE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void MaybeSample::Builder::setNone( ::capnp::Void value) {
  _builder.setDataField<MaybeSample::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, MaybeSample::NONE);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool MaybeSample::Reader::isSome() const {
  return which() == MaybeSample::SOME;
}
inline bool MaybeSample::Builder::isSome() {
  return which() == MaybeSample::SOME;
}
inline typename MaybeSample::Some::Reader MaybeSample::Reader::getSome() const {
  KJ_IREQUIRE((which() == MaybeSample::SOME),
              "Must check which() before get()ing a union member.");
  return typename MaybeSample::Some::Reader(_reader);
}
inline typename MaybeSample::Some::Builder MaybeSample::Builder::getSome() {
  KJ_IREQUIRE((which() == MaybeSample::SOME),
              "Must check which() before get()ing a union member.");
  return typename MaybeSample::Some::Builder(_builder);
}
inline typename MaybeSample::Some::Builder MaybeSample::Builder::initSome() {
  _builder.setDataField<MaybeSample::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, MaybeSample::SOME);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  _builder.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS).clear();
  _builder.getPointerField(::capnp::bounded<2>() * ::capnp::POINTERS).clear();
  return typename MaybeSample::Some::Builder(_builder);
}
inline bool MaybeSample::Some::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool MaybeSample::Some::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader MaybeSample::Some::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder MaybeSample::Some::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void MaybeSample::Some::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder MaybeSample::Some::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void MaybeSample::Some::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> MaybeSample::Some::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool MaybeSample::Some::Reader::hasBrr() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool MaybeSample::Some::Builder::hasBrr() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Reader MaybeSample::Some::Reader::getBrr() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Builder MaybeSample::Some::Builder::getBrr() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void MaybeSample::Some::Builder::setBrr( ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void MaybeSample::Some::Builder::setBrr(::kj::ArrayPtr<const  ::uint8_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Builder MaybeSample::Some::Builder::initBrr(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void MaybeSample::Some::Builder::adoptBrr(
    ::capnp::Orphan< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>> MaybeSample::Some::Builder::disownBrr() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint16_t MaybeSample::Some::Reader::getLoopByte() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t MaybeSample::Some::Builder::getLoopByte() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void MaybeSample::Some::Builder::setLoopByte( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool MaybeSample::Some::Reader::hasTuning() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool MaybeSample::Some::Builder::hasTuning() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::serialize::generated::SampleTuning::Reader MaybeSample::Some::Reader::getTuning() const {
  return ::capnp::_::PointerHelpers< ::serialize::generated::SampleTuning>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::serialize::generated::SampleTuning::Builder MaybeSample::Some::Builder::getTuning() {
  return ::capnp::_::PointerHelpers< ::serialize::generated::SampleTuning>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::serialize::generated::SampleTuning::Pipeline MaybeSample::Some::Pipeline::getTuning() {
  return  ::serialize::generated::SampleTuning::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void MaybeSample::Some::Builder::setTuning( ::serialize::generated::SampleTuning::Reader value) {
  ::capnp::_::PointerHelpers< ::serialize::generated::SampleTuning>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::serialize::generated::SampleTuning::Builder MaybeSample::Some::Builder::initTuning() {
  return ::capnp::_::PointerHelpers< ::serialize::generated::SampleTuning>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void MaybeSample::Some::Builder::adoptTuning(
    ::capnp::Orphan< ::serialize::generated::SampleTuning>&& value) {
  ::capnp::_::PointerHelpers< ::serialize::generated::SampleTuning>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::serialize::generated::SampleTuning> MaybeSample::Some::Builder::disownTuning() {
  return ::capnp::_::PointerHelpers< ::serialize::generated::SampleTuning>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::uint8_t Adsr::Reader::getAttack() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Adsr::Builder::getAttack() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Adsr::Builder::setAttack( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t Adsr::Reader::getDecay() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Adsr::Builder::getDecay() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Adsr::Builder::setDecay( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t Adsr::Reader::getSustain() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Adsr::Builder::getSustain() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Adsr::Builder::setSustain( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t Adsr::Reader::getRelease() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Adsr::Builder::getRelease() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Adsr::Builder::setRelease( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t InstrumentPatch::Reader::getMinNote() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t InstrumentPatch::Builder::getMinNote() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void InstrumentPatch::Builder::setMinNote( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t InstrumentPatch::Reader::getSampleIdx() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t InstrumentPatch::Builder::getSampleIdx() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void InstrumentPatch::Builder::setSampleIdx( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool InstrumentPatch::Reader::hasAdsr() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool InstrumentPatch::Builder::hasAdsr() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::serialize::generated::Adsr::Reader InstrumentPatch::Reader::getAdsr() const {
  return ::capnp::_::PointerHelpers< ::serialize::generated::Adsr>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::serialize::generated::Adsr::Builder InstrumentPatch::Builder::getAdsr() {
  return ::capnp::_::PointerHelpers< ::serialize::generated::Adsr>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::serialize::generated::Adsr::Pipeline InstrumentPatch::Pipeline::getAdsr() {
  return  ::serialize::generated::Adsr::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void InstrumentPatch::Builder::setAdsr( ::serialize::generated::Adsr::Reader value) {
  ::capnp::_::PointerHelpers< ::serialize::generated::Adsr>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::serialize::generated::Adsr::Builder InstrumentPatch::Builder::initAdsr() {
  return ::capnp::_::PointerHelpers< ::serialize::generated::Adsr>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void InstrumentPatch::Builder::adoptAdsr(
    ::capnp::Orphan< ::serialize::generated::Adsr>&& value) {
  ::capnp::_::PointerHelpers< ::serialize::generated::Adsr>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::serialize::generated::Adsr> InstrumentPatch::Builder::disownAdsr() {
  return ::capnp::_::PointerHelpers< ::serialize::generated::Adsr>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::serialize::generated::MaybeInstrument::Which MaybeInstrument::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::serialize::generated::MaybeInstrument::Which MaybeInstrument::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool MaybeInstrument::Reader::isNone() const {
  return which() == MaybeInstrument::NONE;
}
inline bool MaybeInstrument::Builder::isNone() {
  return which() == MaybeInstrument::NONE;
}
inline  ::capnp::Void MaybeInstrument::Reader::getNone() const {
  KJ_IREQUIRE((which() == MaybeInstrument::NONE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void MaybeInstrument::Builder::getNone() {
  KJ_IREQUIRE((which() == MaybeInstrument::NONE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void MaybeInstrument::Builder::setNone( ::capnp::Void value) {
  _builder.setDataField<MaybeInstrument::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, MaybeInstrument::NONE);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool MaybeInstrument::Reader::isSome() const {
  return which() == MaybeInstrument::SOME;
}
inline bool MaybeInstrument::Builder::isSome() {
  return which() == MaybeInstrument::SOME;
}
inline typename MaybeInstrument::Some::Reader MaybeInstrument::Reader::getSome() const {
  KJ_IREQUIRE((which() == MaybeInstrument::SOME),
              "Must check which() before get()ing a union member.");
  return typename MaybeInstrument::Some::Reader(_reader);
}
inline typename MaybeInstrument::Some::Builder MaybeInstrument::Builder::getSome() {
  KJ_IREQUIRE((which() == MaybeInstrument::SOME),
              "Must check which() before get()ing a union member.");
  return typename MaybeInstrument::Some::Builder(_builder);
}
inline typename MaybeInstrument::Some::Builder MaybeInstrument::Builder::initSome() {
  _builder.setDataField<MaybeInstrument::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, MaybeInstrument::SOME);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  _builder.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS).clear();
  return typename MaybeInstrument::Some::Builder(_builder);
}
inline bool MaybeInstrument::Some::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool MaybeInstrument::Some::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader MaybeInstrument::Some::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder MaybeInstrument::Some::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void MaybeInstrument::Some::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder MaybeInstrument::Some::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void MaybeInstrument::Some::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> MaybeInstrument::Some::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool MaybeInstrument::Some::Reader::hasKeysplit() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool MaybeInstrument::Some::Builder::hasKeysplit() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::serialize::generated::InstrumentPatch,  ::capnp::Kind::STRUCT>::Reader MaybeInstrument::Some::Reader::getKeysplit() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::InstrumentPatch,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::serialize::generated::InstrumentPatch,  ::capnp::Kind::STRUCT>::Builder MaybeInstrument::Some::Builder::getKeysplit() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::InstrumentPatch,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void MaybeInstrument::Some::Builder::setKeysplit( ::capnp::List< ::serialize::generated::InstrumentPatch,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::InstrumentPatch,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::serialize::generated::InstrumentPatch,  ::capnp::Kind::STRUCT>::Builder MaybeInstrument::Some::Builder::initKeysplit(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::InstrumentPatch,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void MaybeInstrument::Some::Builder::adoptKeysplit(
    ::capnp::Orphan< ::capnp::List< ::serialize::generated::InstrumentPatch,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::InstrumentPatch,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::serialize::generated::InstrumentPatch,  ::capnp::Kind::STRUCT>> MaybeInstrument::Some::Builder::disownKeysplit() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::InstrumentPatch,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline double SequencerOptions::Reader::getTargetTempo() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double SequencerOptions::Builder::getTargetTempo() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void SequencerOptions::Builder::setTargetTempo(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t SequencerOptions::Reader::getSpcTimerPeriod() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t SequencerOptions::Builder::getSpcTimerPeriod() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void SequencerOptions::Builder::setSpcTimerPeriod( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t SequencerOptions::Reader::getTicksPerBeat() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t SequencerOptions::Builder::getTicksPerBeat() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void SequencerOptions::Builder::setTicksPerBeat( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t PerChannelSettings::Reader::getNEffectCol() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 1u);
}

inline  ::uint8_t PerChannelSettings::Builder::getNEffectCol() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 1u);
}
inline void PerChannelSettings::Builder::setNEffectCol( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, 1u);
}

inline  ::uint32_t Document::Reader::getVersion() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Document::Builder::getVersion() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Document::Builder::setVersion( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Document::Reader::hasSequencerOptions() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Document::Builder::hasSequencerOptions() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::serialize::generated::SequencerOptions::Reader Document::Reader::getSequencerOptions() const {
  return ::capnp::_::PointerHelpers< ::serialize::generated::SequencerOptions>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::serialize::generated::SequencerOptions::Builder Document::Builder::getSequencerOptions() {
  return ::capnp::_::PointerHelpers< ::serialize::generated::SequencerOptions>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::serialize::generated::SequencerOptions::Pipeline Document::Pipeline::getSequencerOptions() {
  return  ::serialize::generated::SequencerOptions::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Document::Builder::setSequencerOptions( ::serialize::generated::SequencerOptions::Reader value) {
  ::capnp::_::PointerHelpers< ::serialize::generated::SequencerOptions>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::serialize::generated::SequencerOptions::Builder Document::Builder::initSequencerOptions() {
  return ::capnp::_::PointerHelpers< ::serialize::generated::SequencerOptions>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Document::Builder::adoptSequencerOptions(
    ::capnp::Orphan< ::serialize::generated::SequencerOptions>&& value) {
  ::capnp::_::PointerHelpers< ::serialize::generated::SequencerOptions>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::serialize::generated::SequencerOptions> Document::Builder::disownSequencerOptions() {
  return ::capnp::_::PointerHelpers< ::serialize::generated::SequencerOptions>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Document::Reader::hasFrequencyTable() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Document::Builder::hasFrequencyTable() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader Document::Reader::getFrequencyTable() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder Document::Builder::getFrequencyTable() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Document::Builder::setFrequencyTable( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void Document::Builder::setFrequencyTable(::kj::ArrayPtr<const double> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder Document::Builder::initFrequencyTable(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Document::Builder::adoptFrequencyTable(
    ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> Document::Builder::disownFrequencyTable() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::serialize::generated::AccidentalMode Document::Reader::getAccidentalMode() const {
  return _reader.getDataField< ::serialize::generated::AccidentalMode>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::serialize::generated::AccidentalMode Document::Builder::getAccidentalMode() {
  return _builder.getDataField< ::serialize::generated::AccidentalMode>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Document::Builder::setAccidentalMode( ::serialize::generated::AccidentalMode value) {
  _builder.setDataField< ::serialize::generated::AccidentalMode>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t Document::Reader::getZoomLevel() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Document::Builder::getZoomLevel() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Document::Builder::setZoomLevel( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t Document::Reader::getEffectNameChars() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, 1u);
}

inline  ::uint8_t Document::Builder::getEffectNameChars() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, 1u);
}
inline void Document::Builder::setEffectNameChars( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, value, 1u);
}

inline bool Document::Reader::hasSamples() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Document::Builder::hasSamples() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::serialize::generated::MaybeSample,  ::capnp::Kind::STRUCT>::Reader Document::Reader::getSamples() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::MaybeSample,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::serialize::generated::MaybeSample,  ::capnp::Kind::STRUCT>::Builder Document::Builder::getSamples() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::MaybeSample,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Document::Builder::setSamples( ::capnp::List< ::serialize::generated::MaybeSample,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::MaybeSample,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::serialize::generated::MaybeSample,  ::capnp::Kind::STRUCT>::Builder Document::Builder::initSamples(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::MaybeSample,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Document::Builder::adoptSamples(
    ::capnp::Orphan< ::capnp::List< ::serialize::generated::MaybeSample,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::MaybeSample,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::serialize::generated::MaybeSample,  ::capnp::Kind::STRUCT>> Document::Builder::disownSamples() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::MaybeSample,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Document::Reader::hasInstruments() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Document::Builder::hasInstruments() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::serialize::generated::MaybeInstrument,  ::capnp::Kind::STRUCT>::Reader Document::Reader::getInstruments() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::MaybeInstrument,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::serialize::generated::MaybeInstrument,  ::capnp::Kind::STRUCT>::Builder Document::Builder::getInstruments() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::MaybeInstrument,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Document::Builder::setInstruments( ::capnp::List< ::serialize::generated::MaybeInstrument,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::MaybeInstrument,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::serialize::generated::MaybeInstrument,  ::capnp::Kind::STRUCT>::Builder Document::Builder::initInstruments(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::MaybeInstrument,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void Document::Builder::adoptInstruments(
    ::capnp::Orphan< ::capnp::List< ::serialize::generated::MaybeInstrument,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::MaybeInstrument,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::serialize::generated::MaybeInstrument,  ::capnp::Kind::STRUCT>> Document::Builder::disownInstruments() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::MaybeInstrument,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Document::Reader::hasChips() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool Document::Builder::hasChips() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::serialize::generated::ChipKind,  ::capnp::Kind::ENUM>::Reader Document::Reader::getChips() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::ChipKind,  ::capnp::Kind::ENUM>>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::serialize::generated::ChipKind,  ::capnp::Kind::ENUM>::Builder Document::Builder::getChips() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::ChipKind,  ::capnp::Kind::ENUM>>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void Document::Builder::setChips( ::capnp::List< ::serialize::generated::ChipKind,  ::capnp::Kind::ENUM>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::ChipKind,  ::capnp::Kind::ENUM>>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline void Document::Builder::setChips(::kj::ArrayPtr<const  ::serialize::generated::ChipKind> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::ChipKind,  ::capnp::Kind::ENUM>>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::serialize::generated::ChipKind,  ::capnp::Kind::ENUM>::Builder Document::Builder::initChips(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::ChipKind,  ::capnp::Kind::ENUM>>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), size);
}
inline void Document::Builder::adoptChips(
    ::capnp::Orphan< ::capnp::List< ::serialize::generated::ChipKind,  ::capnp::Kind::ENUM>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::ChipKind,  ::capnp::Kind::ENUM>>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::serialize::generated::ChipKind,  ::capnp::Kind::ENUM>> Document::Builder::disownChips() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::ChipKind,  ::capnp::Kind::ENUM>>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool Document::Reader::hasChipChannelSettings() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool Document::Builder::hasChipChannelSettings() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::List< ::serialize::generated::PerChannelSettings,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>::Reader Document::Reader::getChipChannelSettings() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::serialize::generated::PerChannelSettings,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::List< ::serialize::generated::PerChannelSettings,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>::Builder Document::Builder::getChipChannelSettings() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::serialize::generated::PerChannelSettings,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void Document::Builder::setChipChannelSettings( ::capnp::List< ::capnp::List< ::serialize::generated::PerChannelSettings,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::serialize::generated::PerChannelSettings,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline void Document::Builder::setChipChannelSettings(::kj::ArrayPtr<const  ::capnp::List< ::serialize::generated::PerChannelSettings,  ::capnp::Kind::STRUCT>::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::serialize::generated::PerChannelSettings,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::List< ::serialize::generated::PerChannelSettings,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>::Builder Document::Builder::initChipChannelSettings(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::serialize::generated::PerChannelSettings,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), size);
}
inline void Document::Builder::adoptChipChannelSettings(
    ::capnp::Orphan< ::capnp::List< ::capnp::List< ::serialize::generated::PerChannelSettings,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::serialize::generated::PerChannelSettings,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::List< ::serialize::generated::PerChannelSettings,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>> Document::Builder::disownChipChannelSettings() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::serialize::generated::PerChannelSettings,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool Document::Reader::hasTimeline() const {
  return !_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline bool Document::Builder::hasTimeline() {
  return !_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::serialize::generated::TimelineFrame,  ::capnp::Kind::STRUCT>::Reader Document::Reader::getTimeline() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::TimelineFrame,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::serialize::generated::TimelineFrame,  ::capnp::Kind::STRUCT>::Builder Document::Builder::getTimeline() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::TimelineFrame,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline void Document::Builder::setTimeline( ::capnp::List< ::serialize::generated::TimelineFrame,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::TimelineFrame,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::serialize::generated::TimelineFrame,  ::capnp::Kind::STRUCT>::Builder Document::Builder::initTimeline(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::TimelineFrame,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), size);
}
inline void Document::Builder::adoptTimeline(
    ::capnp::Orphan< ::capnp::List< ::serialize::generated::TimelineFrame,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::TimelineFrame,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::serialize::generated::TimelineFrame,  ::capnp::Kind::STRUCT>> Document::Builder::disownTimeline() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::serialize::generated::TimelineFrame,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}

}  // namespace
}  // namespace

CAPNP_END_HEADER

