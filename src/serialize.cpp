#include "doc/validate.h"
#include "serialize.h"
#include "serialize/document.capnp.h"
#include "chip_kinds.h"
#include "util/copy_move.h"
#include "util/expr.h"
#include "util/release_assert.h"

#include <fmt/core.h>
#include <fmt/compile.h>
#include <kj/common.h>
#include <kj/function.h>
#include <kj/memory.h>
#include <kj/filesystem.h>
#include <capnp/message.h>
#include <capnp/serialize-packed.h>

#include <iterator>  // std::back_inserter
#include <limits>  // std::numeric_limits
#include <optional>
#include <string_view>

namespace serialize {

/// gen stands for autogenerated.
namespace gen = generated;
using namespace doc;
using chip_common::MAX_NCHIP;

/// Cap'n Proto uses 8-byte (64-bit) words.
static constexpr size_t BYTES_PER_WORD = 8;

/// The recommended serializer is MallocMessageBuilder.
/// When a message overflows the initial malloc'd buffer, MallocMessageBuilder
/// splits up messages into segments rather than growing the buffer.
/// I dislike this because the resulting files are more complex to process.
/// To prevent this from happening, allocate a very large buffer.
static constexpr size_t INITIAL_SIZE_BYTES = 1024 * 1024;

/// I thought mimicking &mut was a good idea. I ended up not applying it consistently.
#define MUT

/// All serialize-inner-type functions have internal linkage.
namespace {

using uint = unsigned int;
using std::optional;
using std::tuple;
using std::vector;

// During deserialization, not all values listed in the schema may be present.
// I don't know what happens when I dereference a missing "pointer type",
// but it probably won't segfault/UB in capnp, just return a "zero value".
// (flatbuffers returns a pointer, which I think is nullable and unsafe to dereference.)
//
// Missing-field handling bugs will likely never be caught during testing,
// since missing values never occur in files generated in any past program version,
// only in future versions where I omit old deprecated fields.
//
// I think it's safe to handle removing fields on a case-by-case basis,
// where every time I deprecate a field I manually evaluate its impact
// on past program versions, and pick whether to remove or write placeholder data, etc.
// As for malicious files, capnp is probably memory-safe
// (whereas flatbuffers returning raw pointers does not inspire confidence).

template<typename T>
inline kj::ArrayPtr<T const> array_ptr(std::vector<T> const& vec) {
    return kj::ArrayPtr<T const>(vec.data(), vec.size());
}

template<typename T, size_t N>
inline kj::ArrayPtr<T const> array_ptr(gsl::span<T, N> span) {
    return kj::ArrayPtr<T const>(span.data(), span.size());
}

template<typename T>
inline gsl::span<T const> span(std::vector<T> const& vec) {
    return gsl::span<T const>(vec.data(), vec.size());
}

template<typename T, size_t N>
inline gsl::span<T const> span(std::array<T, N> const& arr) {
    return gsl::span<T const>(arr.data(), arr.size());
}

/// Finds the length to which you can truncate the array
/// while keeping all non-nullopt elements.
template<typename T>
inline size_t leading_size(gsl::span<optional<T> const> data) {
    for (size_t i = data.size(); i--; ) {
        if (data[i].has_value()) {
            return i + 1;
        }
    }
    return 0;
}

template<typename Element, typename ListBuilder, typename F>
inline void serialize_all(
    gsl::span<Element const> items, ListBuilder gen_items, F func
) {
    uint num_to_write = gen_items.size();
    release_assert_equal(num_to_write, items.size());

    for (uint i = 0; i < num_to_write; i++) {
        func(items[i], MUT gen_items[i]);
    }
}

// gen::T::Builder is small and can be passed by value (akin to reborrowing).

void serialize_sequencer_options(
    SequencerOptions const& seq_options, gen::SequencerOptions::Builder gen_options
) {
    gen_options.setTargetTempo(seq_options.target_tempo);
    gen_options.setNoteGapTicks((uint16_t) seq_options.note_gap_ticks);
    gen_options.setTicksPerBeat((uint16_t) seq_options.ticks_per_beat);
    gen_options.setBeatsPerMeasure((uint16_t) seq_options.beats_per_measure);
    gen_options.setSpcTimerPeriod((uint16_t) seq_options.spc_timer_period);
}

void serialize_sample(
    MaybeSample const& sample, gen::MaybeSample::Builder gen_maybe_sample
) {
    if (sample) {
        auto gen_sample = gen_maybe_sample.initSome();
        gen_sample.setName(sample->name);
        gen_sample.setBrr(array_ptr(sample->brr));
        gen_sample.setLoopByte(sample->loop_byte);
        {
            SampleTuning const& tuning = sample->tuning;
            auto gen_tuning = gen_sample.initTuning();

            gen_tuning.setSampleRate(tuning.sample_rate);
            gen_tuning.setRootKey(tuning.root_key);
            gen_tuning.setDetuneCents(tuning.detune_cents);
        }
    }
}

void serialize_instrument(
    MaybeInstrument const& instr, gen::MaybeInstrument::Builder gen_maybe_instr
) {
    if (instr) {
        auto gen_instr = gen_maybe_instr.initSome();
        // @1
        gen_instr.setName(instr->name);

        // @2 MaybeInstrument::keysplit
        {
            auto serialize_patch = [](
                InstrumentPatch const& patch,
                gen::InstrumentPatch::Builder gen_patch)
            {
                gen_patch.setMinNote(patch.min_note);
                gen_patch.setSampleIdx(patch.sample_idx);

                auto gen_adsr = gen_patch.initAdsr();
                Adsr const& adsr = patch.adsr;

                gen_adsr.setAttack(adsr.attack_rate);
                gen_adsr.setDecay(adsr.decay_rate);
                gen_adsr.setSustain(adsr.sustain_level);
                gen_adsr.setRelease(adsr.decay_2);
            };

            auto num_patches = instr->keysplit.size();
            release_assert(num_patches <= MAX_KEYSPLITS);
            serialize_all(
                span(instr->keysplit),
                gen_instr.initKeysplit((uint) num_patches),
                serialize_patch);
        }
    }
}

void serialize_event(
    TimedRowEvent const& event, gen::TimedRowEvent::Builder gen_event
) {
    gen_event.setAnchorTick(event.anchor_tick);

    RowEvent const& v = event.v;
    if (v.note) {
        gen_event.getNote().setSome(v.note->value);
    }
    if (v.instr) {
        gen_event.getInstr().setSome(*v.instr);
    }
    if (v.volume) {
        gen_event.getVolume().setSome(*v.volume);
    }

    // TODO only serialize visible effect columns, based on
    // SequenceTrack/ChannelSettings
    auto effects = span(v.effects);
    // v.effects is a fixed-size array span, this is guaranteed to not truncate.
    auto num_effects = (uint) leading_size(effects);
    effects = effects.subspan(0, num_effects);
    if (num_effects) {
        serialize_all(effects, gen_event.initEffects(num_effects), [](
            MaybeEffect const& effect, gen::MaybeEffect::Builder gen_effect
        ) {
            if (effect) {
                gen_effect.setName0((uint8_t) effect->name[0]);
                gen_effect.setName1((uint8_t) effect->name[1]);
                gen_effect.setValue(effect->value);
            }
        });
    }
}

void serialize_pattern(Pattern const& pattern, gen::Pattern::Builder gen_pattern) {
    TimedEventsRef events = span(pattern.events);
    auto num_events = events.size();
    release_assert(num_events <= MAX_EVENTS_PER_PATTERN);

    gen_pattern.setLengthTicks(pattern.length_ticks);

    serialize_all(events, gen_pattern.initEvents((uint) num_events), serialize_event);
}

void serialize_track_block(
    TrackBlock const& block, gen::TrackBlock::Builder gen_block
) {
    gen_block.setBeginTick(block.begin_tick);
    gen_block.setLoopCount(block.loop_count);
    serialize_pattern(block.pattern, gen_block.initPattern());
}

void serialize_track(
    SequenceTrack const& track, gen::SequenceTrack::Builder gen_track
) {
    gsl::span<TrackBlock const> blocks = track.blocks;
    release_assert(blocks.size() <= MAX_BLOCKS_PER_TRACK);
    auto num_blocks = (uint) blocks.size();

    // SequenceTrack::blocks @0 :List(TrackBlock)
    serialize_all(
        blocks, gen_track.initBlocks(num_blocks), serialize_track_block
    );

    // SequenceTrack::nEffectCol @1 :UInt8
    {
        ChannelSettings const& settings = track.settings;
        gen_track.setNEffectCol(settings.n_effect_col);
    }
}

// Here are parts of serialize_impl() which allocate individual list fields of
// gen::Document. These were extracted into subroutines to simplify the long function.
// Do NOT move these functions further up; it causes confusion.

void init_serialize_samples(Samples const& samples_, gen::Document::Builder gen_doc) {
    auto samples = samples_.dyn_span();
    release_assert_equal(samples.size(), MAX_SAMPLES);

    auto num_samples = (uint) leading_size(samples);
    samples = samples.subspan(0, num_samples);
    serialize_all(samples, gen_doc.initSamples(num_samples), serialize_sample);
}

void init_serialize_instruments(
    Instruments const& instruments_, gen::Document::Builder gen_doc
) {
    auto instruments = instruments_.dyn_span();
    release_assert_equal(instruments.size(), MAX_INSTRUMENTS);

    auto num_instr = (uint) leading_size(instruments);
    instruments = instruments.subspan(0, num_instr);
    serialize_all(
        instruments,
        gen_doc.initInstruments(num_instr),
        serialize_instrument);
}

void init_serialize_chips(ChipList const& chips, gen::Document::Builder gen_doc) {
    auto num_chips = (uint) chips.size();
    auto gen_chips = gen_doc.initChips(num_chips);

    // so close, yet so far, to getting a reusable abstraction.
    for (uint i = 0; i < num_chips; i++) {
        gen_chips.set(i, EXPR(switch (chips[i]) {
            case ChipKind::Spc700: return gen::ChipKind::SPC700;
            default:
                assert(false && "Unrecognized ChipKind when serializing document");
                return gen::ChipKind::UNKNOWN;
        }));
    }
}

void init_serialize_sequence(
    Sequence const& sequence, gen::Document::Builder gen_doc
) {
    auto num_chips = (uint) sequence.size();
    auto gen_sequence = gen_doc.initSequence(num_chips);

    for (uint chip = 0; chip < num_chips; chip++) {
        auto const& channel_tracks = sequence[chip];

        auto num_channels = channel_tracks.size();
        release_assert(num_channels <= chip_common::MAX_NCHAN_PER_CHIP);
        auto gen_channel_tracks = gen_sequence.init(chip, (uint) num_channels);

        for (uint chan = 0; chan < num_channels; chan++) {
            SequenceTrack const& track = channel_tracks[chan];
            auto gen_track = gen_channel_tracks[chan];

            serialize_track(track, MUT gen_track);
        }
    }
}

using ::capnp::MallocMessageBuilder;

/// Function called on a serialized document.
/// For example, you can pass in a lambda that writes a serialized document to disk
/// with a specified filename.
using BuilderCallback = kj::FunctionParam<void(MallocMessageBuilder &)>;

void serialize_impl(
    Document const& doc, Metadata metadata, BuilderCallback callback
) {
    auto builder = MallocMessageBuilder(INITIAL_SIZE_BYTES / BYTES_PER_WORD);

    auto gen_doc = builder.initRoot<gen::Document>();

    // In capnp's c++ api, initBar() is the only way to get a builder
    // pointing to an object already "owned" by a parent,
    // allowing you to set fields one by one.
    //
    // Initially the parent owns the &mut MessageBuilder,
    // and creating a child builder reborrows the MessageBuilder
    // and (by Rust rules) stops other messages from being built concurrently.
    // This feels a lot like C++ constructors and placement new.
    //
    // FlatBuffers feels closer to Rust factory functions.
    // In FlatBuffers, you create an object from a "global allocator", get a handle,
    // then create a parent object and move the handles into it.
    // But that has the restriction that only one object can be in the process
    // of initialization at a time... which is unpleasant.

    // @0
    gen_doc.setVersion(gen::Versions::CURRENT);

    // @1 Document::sequencerOptions
    serialize_sequencer_options(doc.sequencer_options, gen_doc.initSequencerOptions());

    // @2
    gen_doc.setFrequencyTable(array_ptr(doc.frequency_table.span()));

    // @3
    gen_doc.setAccidentalMode(EXPR(switch (doc.accidental_mode) {
        case AccidentalMode::Sharp: return gen::AccidentalMode::SHARP;
        case AccidentalMode::Flat: return gen::AccidentalMode::FLAT;
        default:
            assert(false && "Unrecognized AccidentalMode when serializing document");
            return gen::AccidentalMode(0);
    }));

    // @4
    gen_doc.setTicksPerRow(metadata.ticks_per_row);

    // @5
    gen_doc.setEffectNameChars(doc.effect_name_chars);

    // @6 Document::samples
    init_serialize_samples(doc.samples, MUT gen_doc);

    // @7 Document::instruments
    init_serialize_instruments(doc.instruments, MUT gen_doc);

    release_assert(doc.chips.size() <= MAX_NCHIP);

    // @8 Document::chips
    init_serialize_chips(doc.chips, MUT gen_doc);

    // @9 Document::sequence
    init_serialize_sequence(doc.sequence, MUT gen_doc);

    return callback(builder);
}

namespace _ {
using namespace kj;

/// Shim allowing Cap'n Proto to write to a kj::File.
class FileOutputStream final: public OutputStream {
private:
    // non-null, non-owning pointer
    File const* _file;
    size_t _cursor = 0;

public:
    FileOutputStream(File const& fileParam)
        : _file(&fileParam)
    {}

    void write(const void* buffer, size_t size) override {
        _file->write(_cursor, arrayPtr(reinterpret_cast<const byte*>(buffer), size));
        _cursor += size;
    }
};
}
using _::FileOutputStream;

void write_to_file(kj::File const& file, MallocMessageBuilder & builder) {
    file.truncate(0);
    auto stream = FileOutputStream(file);

    // Write the magic number to the front of the file.
    auto magic_number = gen::MAGIC_NUMBER.get();
    stream.write(magic_number.begin(), magic_number.size());

    capnp::writePackedMessage(stream, builder);
}

std::string_view string_view(kj::StringPtr str) {
    return std::string_view(str.begin(), str.size());
}

std::string_view format_file_type(kj::FsNode::Type type) {
    // I hope kj will *never* reorder the Type enum, append elements,
    // or construct invalid enum values.
    // The vendored kj will never change,
    // but updating capnp/kj may require changing this array.
    static std::string_view errors[] = {
        "FILE",
        "DIRECTORY",
        "SYMLINK",
        "BLOCK_DEVICE",
        "CHARACTER_DEVICE",
        "NAMED_PIPE",
        "SOCKET",
        "OTHER",
    };
    return errors[(size_t) type];
}

std::optional<std::string> save_impl(
    Document const& doc, Metadata metadata, char const* path
) {
    // TODO add https://lamarrr.github.io/STX/structstx_1_1Result.html.
    // do error messages need to be translated?

    // on Windows, while this object exists, C:/ and the working directory are locked.
    // I would *not* keep it around, despite what the docs say.
    kj::Own<kj::Filesystem> fs = kj::newDiskFilesystem();
    kj::Path abs_path = fs->getCurrentPath().evalNative(path);

    // Holds a reference to abs_path.
    kj::PathPtr parent = abs_path.parent();
    kj::PathPtr basename = abs_path.basename();

    auto dir_open = fs->getRoot().openSubdir(parent, kj::WriteMode::MODIFY);

    // If the input path is a directory, fail instead of replacing it with a file.
    // (This is a best-effort attempt, vulnerable to TOCTTOU race conditions,
    // but I don't care).
    auto maybe_metadata = dir_open->tryLstat(basename);
    KJ_IF_MAYBE(m, maybe_metadata) {
        // We replace files with new files (OK), and replace symlinks with new files
        // (bad, maybe we should resolve the symlink, but IDK if it's better than not
        // saving at all).
        // Other special file types result in a save error.
        if (m->type != kj::FsNode::Type::FILE && m->type != kj::FsNode::Type::SYMLINK) {
            return fmt::format("cannot overwrite path \"{}\", has type {}",
                string_view(abs_path.toString(true)), format_file_type(m->type)
            );
        }
    }

    // TODO add "save options" with backup toggle.
    // Pick a backup dir (.? ./Backups? ~/Documents/ExoTracker/Backups?).
    // If "backup files" is true, while the source path exists
    // (either check its existence each iteration, or lock it in place while renaming),
    // run Directory::tryTransfer() to
    // backup dir/(original name, date/time, incrementing counter)
    // with WriteMode::CREATE (do not overwrite existing backups of the same timestamp)
    // until it succeeds.

    // "The `CREATE` and `MODIFY` bits of `mode` are not enforced until commit time."
    auto tx = dir_open->replaceFile(
        basename, kj::WriteMode::CREATE | kj::WriteMode::MODIFY
    );
    kj::File const& file = tx->get();

    serialize_impl(doc, metadata, [&file](MallocMessageBuilder & builder) {
        write_to_file(file, builder);
    });

    // Directory::Replacer::commit() doesn't sync the file before renaming it.
    // Is syncing necessary? It depends.
    // https://en.wikipedia.org/wiki/Ext4#Delayed_allocation_and_potential_data_loss
    // https://unix.stackexchange.com/questions/464382/which-filesystems-require-fsync-for-crash-safety-when-replacing-an-existing-fi
    // No clue on Windows.
    file.sync();

    // See commit() doc comments for details on atomic saving.
    tx->commit();

    // Don't call dir_open.sync().
    // It's not worthwhile to fsync the parent directory on Linux
    // because we only need crash atomicity, not flushing the rename to disk.
    // And on Windows, dir_open.sync() is not possible, and throws an exception.

    return {};
}

}  // anonymous namespace

/// What encoding-related issues do we have with paths?
///
/// ## Linux: Qt/QString are fundamentally broken
///
/// Linux filenames are actually bags of raw bytes, with no fixed encoding
/// (but systems today universally store UTF-8).
///
/// QFileDialog/QFile operate on QString, which is UTF-16.
///
/// When converting a Linux filename to a QString,
/// Qt mangles the names of non-UTF-8 files
/// (at least if Linux's locale uses UTF-8 encoding, which is standard today).
/// As a result, QFileDialog/QFile can't properly open/save files with non-UTF-8 names
/// (such as Shift-JIS files extracted from Japanese ZIP files).
///
/// ## Windows: Can be made to work through WTF-8
///
/// Windows filenames (as well as QString) are defined to contain
/// "UTF-16 plus unpaired surrogates".
///
/// kj/filesystem.h accepts StringPtr, which is UTF-8 with a trailing NUL byte.
///
/// We must convert a Windows filename (aka QString) to UTF-8,
/// and kj will convert UTF-8 back to UTF-16 to call Win32 APIs.
/// Ideally, QString::toUtf8() would convert unpaired surrogates into WTF-8
/// (malformed UTF-8), then kj would convert WTF-8 back to UTF-16,
/// but it doesn't work out in practice (though it could be fixed).
/// However, this is a less important bug than Linux,
/// because no language/charset contains unpaired surrogates
/// so a user is unlikely to encounter them "in the wild"
/// (except from slicing UTF-16 strings containing emoji?)
///
/// - QString::toUtf8() indirectly calls QUtf8Functions::toUtf8(),
///   which replaces unpaired surrogates with ?.
///   This function must be replaced with a different algorithm outputting WTF-8
///   (perhaps kj::decodeUtf16()?).
///
/// - kj::PathPtr::forWin32Api() calls kj::encodeWideString()
///   (which flags unpaired surrogates as errors)...
///   then discards the error flag entirely!
///   This works for our purposes.
///
/// We use `char const*` because we convert it into kj::StringPtr,
/// which requires a null terminator, and std::string_view doesn't guarantee one.
///
/// TODO re-export kj::decodeUtf16() in public API?
/// (Ideally we'd return std::string, but that requires an extra copy.)
std::optional<std::string> save_to_path(
    doc::Document const& doc, Metadata metadata, char const* path
) {
    std::optional<std::string> out;
    auto maybe_exception = kj::runCatchingExceptions([&]() {
        out = save_impl(doc, metadata, path);
    });
    KJ_IF_MAYBE(e, maybe_exception) {
        return fmt::format("Error saving file: {}", string_view(e->getDescription()));
    }

    return out;
}

/// All deserialize-inner-type functions have internal linkage.
namespace {

using std::move;

// # Vector.

template<typename T, typename Container>
inline std::vector<T> to_owned(Container ptr) {
    std::vector<T> out;
    out.reserve(ptr.size());
    for (auto && val : ptr) {
        out.push_back(val);
    }
    return out;
}

template<typename T>
std::vector<T> with_capacity(size_t cap) {
    std::vector<T> vec;
    vec.reserve(cap);
    return vec;
}

std::string_view string_view(fmt::memory_buffer const& str) {
    return std::string_view(str.begin(), str.size());
}

std::string string(fmt::memory_buffer const& str) {
    return std::string(str.begin(), str.end());
}

// # Error handling.

using namespace doc::validate;  // validate_*

// # Loading functions
SequencerOptions load_sequencer_options(
    ErrorState & state, gen::SequencerOptions::Reader gen_options
) {
    return validate_sequencer_options(SequencerOptions {
        .target_tempo = gen_options.getTargetTempo(),
        .note_gap_ticks = gen_options.getNoteGapTicks(),
        .ticks_per_beat = gen_options.getTicksPerBeat(),
        .beats_per_measure = gen_options.getBeatsPerMeasure(),
        .spc_timer_period = gen_options.getSpcTimerPeriod(),
    }, state);
}

using GenVecDouble = ::capnp::List<double, ::capnp::Kind::PRIMITIVE>::Reader;
FrequenciesOwned load_frequency_table(ErrorState & state, GenVecDouble gen_freq_table) {
    auto valid_size = truncate_frequency_table(state, gen_freq_table.size());

    FrequenciesOwned freq_table;
    for (uint i = 0; i < valid_size; i++) {
        freq_table[i] = gen_freq_table[i];
    }

    return validate_frequency_table(state, freq_table.span(), valid_size);
}

SampleTuning load_tuning(ErrorState & state, gen::SampleTuning::Reader gen_tuning) {
    return validate_tuning(state, SampleTuning {
        .sample_rate = gen_tuning.getSampleRate(),
        .root_key = gen_tuning.getRootKey(),
        .detune_cents = gen_tuning.getDetuneCents(),
    });
}

Sample load_sample(ErrorState & state, gen::MaybeSample::Some::Reader gen_sample) {
    auto prefix = ErrorPrefixer(state);

    prefix.push_literal(state, ".tuning");
    auto tuning = load_tuning(state, gen_sample.getTuning());
    prefix.pop(state);

    return validate_sample(state, Sample {
        .name = gen_sample.getName(),
        .brr = to_owned<uint8_t>(gen_sample.getBrr()),
        .loop_byte = gen_sample.getLoopByte(),
        .tuning = move(tuning),
    });
}

using GenSamples = ::capnp::List< ::serialize::generated::MaybeSample, ::capnp::Kind::STRUCT>::Reader;
Samples load_samples(ErrorState & state, GenSamples gen_samples) {
    Samples samples;
    auto prefix = ErrorPrefixer(state);

    auto valid_size = truncate_samples(state, gen_samples.size());
    for (uint i = 0; i < valid_size; i++) {
        if (gen_samples[i].isSome()) {
            prefix.push(state, "[{}]", i);
            samples[i] = load_sample(state, gen_samples[i].getSome());
            prefix.pop(state);
        }
    }
    return samples;
}

InstrumentPatch load_patch(ErrorState & state, gen::InstrumentPatch::Reader gen_patch) {
    auto gen_adsr = gen_patch.getAdsr();

    return validate_patch(state, InstrumentPatch {
        .min_note = gen_patch.getMinNote(),
        .sample_idx = gen_patch.getSampleIdx(),
        .adsr = Adsr {
            gen_adsr.getAttack(),
            gen_adsr.getDecay(),
            gen_adsr.getSustain(),
            gen_adsr.getRelease(),
        },
    });
}

Instrument load_instrument(
    ErrorState & state, gen::MaybeInstrument::Some::Reader gen_instr
) {
    auto prefix = ErrorPrefixer(state);

    std::string name = gen_instr.getName();
    auto gen_keysplit = gen_instr.getKeysplit();

    auto num_keysplits = truncate_keysplits(state, gen_keysplit.size());

    std::vector<InstrumentPatch> keysplit;
    keysplit.reserve(num_keysplits);
    for (uint k = 0; k < num_keysplits; k++) {
        prefix.push(state, ".keysplit[{}]", k);
        keysplit.push_back(load_patch(state, gen_keysplit[k]));
        prefix.pop(state);
    }

    return Instrument {
        .name = move(name),
        .keysplit = move(keysplit),
    };
}

using GenInstruments = ::capnp::List< ::serialize::generated::MaybeInstrument, ::capnp::Kind::STRUCT>::Reader;
Instruments load_instruments(ErrorState & state, GenInstruments gen_instruments) {
    Instruments instruments;
    auto prefix = ErrorPrefixer(state);

    auto n_instr = truncate_instruments(state, gen_instruments.size());
    for (uint i = 0; i < n_instr; i++) {
        if (gen_instruments[i].isSome()) {
            prefix.push(state, "[{}]", i);
            instruments[i] = load_instrument(state, gen_instruments[i].getSome());
            prefix.pop(state);
        }
    }
    return instruments;
}

using GenChips = ::capnp::List< ::serialize::generated::ChipKind, ::capnp::Kind::ENUM>::Reader;
optional<ChipList> load_chips(ErrorState & state, GenChips gen_chips) {
    auto err = ErrorFrame(state);

    auto maybe_nchip = validate_nchip(state, gen_chips.size());
    if (!maybe_nchip) {
        return {};
    }
    auto num_chip = *maybe_nchip;

    ChipList chips;
    chips.reserve(num_chip);

    for (uint i = 0; i < num_chip; i++) {
        auto gen_chip = gen_chips[i];
        ChipKind chip_kind;
        /*
        The code to convert from capnp ChipKind to C++ ChipKind
        is specific to Cap'n Proto (so is located in serialize.cpp).
        It does not generalize to converting from text-based formats to C++ ChipKind
        (so is not located in doc/validate.h).

        If I eventually add another binary file format using the same capnp
        ChipKind values, I may find a way to factor this conversion process out.
        (I don't know if instruments will use ChipKind or a new InstrumentKind.)
        */
        switch (gen_chip) {
        case gen::ChipKind::SPC700:
            chip_kind = ChipKind::Spc700;
            break;
        case gen::ChipKind::UNKNOWN:
            PUSH_FATAL(err, "[{}]=ChipKind::UNKNOWN, cannot load", i);
            continue;
        default:
            PUSH_FATAL(err,
                "[{}]={} (unknown chip kind), cannot load", i, (size_t) gen_chip
            );
            continue;
        }

        chips.push_back(chip_kind);
    }

    if (err.has_fatal) {
        return {};
    }
    return {std::move(chips)};
}

MaybeEffect load_effect(
    ErrorState & state, gen::MaybeEffect::Reader gen_effect
) {
    auto gen_name_0 = gen_effect.getName0();
    auto gen_name_1 = gen_effect.getName1();

    if (gen_name_0 == 0 && gen_name_1 == 0) {
        return {};
    }
    auto gen_value = gen_effect.getValue();

    return validate_effect(
        state, Effect(EffectName{(char) gen_name_0, (char) gen_name_1}, gen_value)
    );
}

optional<TimedRowEvent> load_event(
    ErrorState & state,
    gen::TimedRowEvent::Reader gen_event,
    TickT pattern_length)
{
    // TODO validate that event lies within block length? (Requires a new parameter.)
    auto prefix = ErrorPrefixer(state);

    auto anchor_tick = validate_anchor_tick(state, gen_event.getAnchorTick());

    auto gen_note = gen_event.getNote();
    optional<Note> note;
    if (gen_note.isSome()) {
        note = Note(gen_note.getSome());
    }

    auto gen_instr = gen_event.getInstr();
    optional<InstrumentIndex> instr;
    if (gen_instr.isSome()) {
        instr = gen_instr.getSome();
    }

    auto gen_volume = gen_event.getVolume();
    optional<Volume> volume;
    if (gen_volume.isSome()) {
        volume = gen_volume.getSome();
    }

    auto gen_effects = gen_event.getEffects();
    PUSH(".v.effects");
    auto neffect = truncate_effects(state, gen_effects.size());
    POP();

    EffectList effects;
    for (uint i = 0; i < neffect; i++) {
        PUSH(".v.effects[{}]", i);
        effects[i] = load_effect(state, gen_effects[i]);
        POP();
    }

    return validate_event(
        state,
        TimedRowEvent {
            .anchor_tick = anchor_tick,
            .v = RowEvent {
                .note = note,
                .instr = instr,
                .volume = volume,
                .effects = effects,
            }
        },
        pattern_length);
}

optional<Pattern> load_pattern(ErrorState & state, gen::Pattern::Reader gen_pattern) {
    auto prefix = ErrorPrefixer(state);
    bool fatal = false;

    TickT length_ticks = gen_pattern.getLengthTicks();

    auto gen_events = gen_pattern.getEvents();
    auto size = truncate_events(state, gen_events.size());
    auto events = with_capacity<TimedRowEvent>(size);
    for (uint i = 0; i < size; i++) {
        PUSH(".events[{}]", i);
        auto event = load_event(state, gen_events[i], length_ticks);
        POP();
        if (!event) {
            fatal = true;
            continue;
        }
        events.push_back(*event);
    }

    if (fatal) {
        return {};
    }
    // If invalid events were skipped, don't bother verifying events are sorted,
    // since the error messages will contain the wrong indexes.

    // Validate events are sorted <= in time (ignoring delay effects
    // since those depend on column count).
    PUSH(".events");
    events = validate_events(state, move(events), length_ticks);
    POP();

    return validate_pattern(state, Pattern {
        .length_ticks = length_ticks,
        .events = move(events),
    });
}

optional<TrackBlock> load_track_block(
    ErrorState & state, gen::TrackBlock::Reader gen_block
) {
    auto prefix = ErrorPrefixer(state);

    TickT begin_tick = gen_block.getBeginTick();
    uint32_t loop_count = gen_block.getLoopCount();

    PUSH_LITERAL(".pattern");
    auto pattern = load_pattern(state, gen_block.getPattern());
    POP();

    if (!pattern) {
        return {};
    }
    return validate_track_block(state, TrackBlock {
        .begin_tick = begin_tick,
        .loop_count = loop_count,
        .pattern = move(*pattern),
    });
}

ChannelSettings load_channel_settings(
    ErrorState & state, gen::SequenceTrack::Reader gen_track
) {
    return validate_channel_settings(state, ChannelSettings {
        .n_effect_col = gen_track.getNEffectCol(),
    });
}
optional<SequenceTrack> load_track(
    ErrorState & state, gen::SequenceTrack::Reader gen_track
) {
    auto prefix = ErrorPrefixer(state);
    bool has_fatal = false;

    auto gen_blocks = gen_track.getBlocks();
    auto size = truncate_blocks(state, gen_blocks.size());
    auto blocks = with_capacity<TrackBlock>(size);

    for (uint b = 0; b < size; b++) {
        // TODO ensure block start times are monotonic and blocks don't overlap.
        // TODO ensure blocks are within frame bounds. This requires a new parameter.
        PUSH(".blocks[{}]", b);
        auto block = load_track_block(state, gen_blocks[b]);
        POP();
        if (block) {
            blocks.push_back(*block);
        } else {
            has_fatal = true;
        }
    }

    ChannelSettings settings = load_channel_settings(state, gen_track);

    if (has_fatal) {
        return {};
    }
    return {SequenceTrack(move(blocks), settings)};
}

using GenSequence =
    ::capnp::List< ::capnp::List< ::serialize::generated::SequenceTrack,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>::Reader;
optional<Sequence> load_sequence(
    ErrorState & state, GenSequence gen_sequence, ChipMetadataRef chips_metadata
) {
    auto prefix = ErrorPrefixer(state);
    bool has_fatal = false;

    auto maybe_nchip =
        validate_nchip_matches(state, gen_sequence.size(), chips_metadata.size());
    if (!maybe_nchip) {
        return {};
    }
    auto nchip = *maybe_nchip;

    Sequence sequence;
    sequence.reserve(nchip);
    for (uint chip_idx = 0; chip_idx < nchip; chip_idx++) {
        auto gen_channel_tracks = gen_sequence[chip_idx];

        auto maybe_nchan = validate_nchan_matches(
            state, gen_channel_tracks.size(), chips_metadata, chip_idx
        );
        if (!maybe_nchan) {
            has_fatal = true;
            continue;
        }
        auto nchan = *maybe_nchan;

        auto channel_tracks = with_capacity<SequenceTrack>(nchan);
        for (uint chan_idx = 0; chan_idx < nchan; chan_idx++) {
            PUSH("[{}][{}]", chip_idx, chan_idx);
            auto track = load_track(state, gen_channel_tracks[chan_idx]);
            POP();
            if (track) {
                channel_tracks.push_back(move(*track));
            } else {
                has_fatal = true;
            }
        }

        sequence.push_back(channel_tracks);
    }

    if (has_fatal) {
        return {};
    }
    return {move(sequence)};
}

static std::string string_to_hex(gsl::span<const uint8_t> input) {
    static char const hex_digits[] = "0123456789ABCDEF";

    std::string output;
    output.reserve(input.size() * 2);

    bool sep = false;

    for (auto c : input) {
        if (sep) {
            output.push_back(' ');
        }
        output.push_back(hex_digits[c >> 4]);
        output.push_back(hex_digits[c & 0xf]);
        sep = true;
    }

    return output;
}

/// Either throws an exception (after possibly appending to `errors`),
/// or returns a value moved from `errors` (leaving `errors` empty).
///
/// Reading a document with invalid values does not throw exceptions,
/// but only produces error/warning values.
/// Cap'n Proto throws exceptions when it reads corrupted/invalid binary data.
///
/// Exceptions are not caught at any point in this function, only by the caller, load().
/// They do not erase prior error messages,
/// but prevent further loading functions from being called.
LoadDocumentResult load_impl(kj::InputStream & stream, ErrorState & state) {
    // TODO change return type to std::optional<tuple<doc::Document, Metadata>>,
    // and unconditionally write errors by reference, rather than only upon exceptions.
    // Read the magic number from the front of the file.
    auto magic_number = gen::MAGIC_NUMBER.get();

    constexpr size_t MAGIC_SIZE = 8;
    assert(magic_number.size() == MAGIC_SIZE);

    uint8_t gen_magic_number[MAGIC_SIZE];
    stream.read(gen_magic_number, MAGIC_SIZE, MAGIC_SIZE);
    if (magic_number != gen_magic_number) {
        PUSH_ERROR(state,
            "Unrecognized file, expected leading bytes {}, got {}",
            string_to_hex(gsl::span(magic_number.begin(), magic_number.size())),
            string_to_hex(gen_magic_number));
        return LoadDocumentResult::err(move(state.err));
    }

    auto buffered = kj::BufferedInputStreamWrapper(stream);
    auto reader = capnp::PackedMessageReader(buffered);

    auto gen_doc = reader.getRoot<gen::Document>();

    auto prefix = ErrorPrefixer(state);

    uint32_t gen_version = gen_doc.getVersion();
    if (gen_version < gen::Versions::MINIMUM) {
        PUSH_WARNING(state,
            "file version {} is older than minimum supported version {}, file may not load properly",
            gen_version, gen::Versions::MINIMUM
        );
    }
    if (gen_version > gen::Versions::CURRENT) {
        PUSH_WARNING(state,
            "file version {} is newer than latest supported version {}, file may not load properly",
            gen_version, gen::Versions::CURRENT
        );
    }

    auto metadata = Metadata {
        .ticks_per_row = gen_doc.getTicksPerRow(),
    };

    prefix.push(state, "sequencer_options");
    auto sequencer_options =
        load_sequencer_options(state, gen_doc.getSequencerOptions());
    prefix.pop(state);

    prefix.push(state, "frequency_table");
    auto frequency_table = load_frequency_table(state, gen_doc.getFrequencyTable());
    prefix.pop(state);

    auto accidental_mode = EXPR(
        auto gen_accidental_mode = gen_doc.getAccidentalMode();
        switch (gen_accidental_mode) {
        case gen::AccidentalMode::SHARP: return AccidentalMode::Sharp;
        case gen::AccidentalMode::FLAT: return AccidentalMode::Flat;
        default:
            PUSH_WARNING(state,
                "accidental_mode={} unrecognized (should be Sharp or Flat), defaulting to Sharp",
                (size_t) gen_accidental_mode
            );
            return AccidentalMode::Sharp;
    });

    auto effect_name_chars =
        validate_effect_name_chars(state, gen_doc.getEffectNameChars());

    prefix.push(state, "samples");
    auto samples = load_samples(state, gen_doc.getSamples());
    prefix.pop(state);

    prefix.push(state, "instruments");
    auto instruments = load_instruments(state, gen_doc.getInstruments());
    prefix.pop(state);

    prefix.push(state, "chips");
    auto chips = load_chips(state, gen_doc.getChips());
    prefix.pop(state);

    ChipMetadatas chips_metadata;
    if (chips) {
        chips_metadata = compute_chip_metadata(*chips);
    }

    optional<Sequence> sequence = {};
    if (chips) {
        prefix.push(state, "sequence");
        sequence = load_sequence(state, gen_doc.getSequence(), chips_metadata);
        prefix.pop(state);
    }

    if (chips && sequence) {
        return LoadDocumentResult::ok(
            doc::DocumentCopy{
                .sequencer_options = move(sequencer_options),
                .frequency_table = move(frequency_table),
                .accidental_mode = accidental_mode,
                .effect_name_chars = effect_name_chars,
                .samples = move(samples),
                .instruments = move(instruments),
                .chips = move(*chips),
                .sequence = move(*sequence),
            },
            metadata,
            move(state.err));
    } else {
        return LoadDocumentResult::err(move(state.err));
    }
}

/// Does not throw exceptions.
LoadDocumentResult load(kj::InputStream & stream) {
    ErrorState state;
    optional<LoadDocumentResult> out;

    auto maybe_exception = kj::runCatchingExceptions([&]() {
        out = load_impl(stream, state);
    });
    KJ_IF_MAYBE(e, maybe_exception) {
        state.err.push_back(ERR_FMT(
            "Error loading file, at point {}: {}",
            string_view(state.msg), string_view(e->getDescription())
        ));
        return LoadDocumentResult::err(move(state.err));
    }

    release_assert(out);
    return move(*out);
}

namespace _ {
using namespace kj;

/// Shim allowing Cap'n Proto to read from a kj::ReadableFile.
class FileInputStream final : public kj::InputStream {
private:
    // non-null, non-owning pointer
    ReadableFile const* _file;
    size_t _cursor = 0;

public:
    FileInputStream(ReadableFile const& file)
        : _file(&file)
    {}

    size_t tryRead(void* buffer, size_t /*minBytes*/, size_t maxBytes) override {
        // Implements InputStream::tryRead(),
        // which "may return fewer than minBytes on EOF",
        // by delegating to ReadableFile::read(),
        // which returns "less than `buffer.size()`... when EOF occurs mid-buffer."
        auto bytes_read = _file->read(_cursor, ArrayPtr((byte *) buffer, maxBytes));
        _cursor += bytes_read;
        return bytes_read;
    }
};
}
using _::FileInputStream;

}  // anonymous namespace

LoadDocumentResult load_from_path(char const* path) {
    // On Windows, while a kj::Filesystem exists,
    // C:/ and the initial working directory are locked,
    // making it undesirable to keep it around for long periods of time...
    //
    // Though perhaps it doesn't matter as much,
    // since all processes lock the current working directory
    // (though kj::Filesystem continues locking the initial directory
    // even after the process changes working directories).
    kj::Own<kj::Filesystem> fs = kj::newDiskFilesystem();
    kj::Path abs_path = fs->getCurrentPath().evalNative(path);

    // `tryOpenFile()` returns null if the path doesn't exist. Other errors still throw exceptions.
    // For KJ exception guidance, see
    // https://github.com/capnproto/capnproto/blob/master/kjdoc/tour.md#throwing-and-catching-exceptions .
    kj::Own<const kj::ReadableFile> file;
    auto maybe_exception = kj::runCatchingExceptions([&]() {
        file = fs->getRoot().openFile(abs_path);
    });
    KJ_IF_MAYBE(e, maybe_exception) {
        auto description = e->getDescription();
        return LoadDocumentResult::err({
            ERR_FMT("Error opening file {}: {}", path, string_view(description))
        });
    }

    auto stream = FileInputStream(*file);
    return load(stream);
}

LoadDocumentResult LoadDocumentResult::ok(
    doc::Document doc, Metadata metadata, Errors errors
) {
    return LoadDocumentResult(tuple(move(doc), metadata), move(errors));
}

LoadDocumentResult LoadDocumentResult::err(Errors errors) {
    assert(!errors.empty());
    if (errors.size() == 0) {
        errors.push_back(Error {
            .type = ErrorType::Error,
            .description = "Load failed, no error message (this should never happen, please report a bug!)",
        });
    }
    return LoadDocumentResult({}, move(errors));
}

LoadDocumentResult::LoadDocumentResult(
    optional<tuple<doc::Document, Metadata>> v_, Errors errors_
)
    : v(move(v_))
    , errors(move(errors_))
{
    // this should never happen, it's redundant with ok()/err().
    if (!v.has_value()) {
        assert(!errors.empty());
    }
}


}  /// namespace serialize

#ifdef UNITTEST

#include "sample_docs.h"

#include <doctest.h>

#include <fstream>

namespace serialize {

static Document default_doc() {
    Document doc = DocumentCopy(sample_docs::DOCUMENTS.at("dream-fragments"));

    // Change as many parameters as possible, to test round-trip.
    doc.sequencer_options.note_gap_ticks = 2;
    doc.sequencer_options.spc_timer_period = 40;
    doc.accidental_mode = AccidentalMode::Flat;
    doc.effect_name_chars = 2;

    return doc;
}

using namespace std::string_literals;

TEST_CASE("Serialize into memory.") {
    auto d = default_doc();

    serialize_impl(d, Metadata { .ticks_per_row = 12 }, [](MallocMessageBuilder & builder) {

        auto arr = capnp::messageToFlatArray(builder);
        // borrows from arr
        auto buf = arr.asChars();
        (void) buf;
    });
}

TEST_CASE("Ensure that opening a nonexistent path returns an error.") {
    auto path = "file not found i swear"s + MODULE_EXT;
    auto rt = load_from_path(path.c_str());
    CHECK_UNARY_FALSE(rt.v.has_value());
    CHECK_UNARY_FALSE(rt.errors.empty());
}

TEST_CASE("Ensure that round-tripping to file works.") {
    auto doc = default_doc();
    auto metadata = Metadata { .ticks_per_row = 12 };
    auto path = "document-packed"s + MODULE_EXT;

    REQUIRE_UNARY(!save_to_path(doc, metadata, path.c_str()));

    auto rt = load_from_path(path.c_str());
    CHECK_UNARY(rt.errors.empty());

    REQUIRE_UNARY(rt.v.has_value());
    auto & [rt_doc, rt_metadata] = *rt.v;
    CHECK_EQ(rt_doc, doc);
    CHECK_EQ(rt_metadata, metadata);
}

// TODO add save_to_path() optional error message,
// for saving to an invalid/nonwritable path.

TEST_CASE("Ensure that loading a file with corrupted headers returns an error and no document.") {
    auto doc = default_doc();
    auto metadata = Metadata { .ticks_per_row = 12 };
    auto path = "document-packed"s + MODULE_EXT;

    REQUIRE_UNARY(!save_to_path(doc, metadata, path.c_str()));

    {
        kj::Own<kj::Filesystem> fs = kj::newDiskFilesystem();
        kj::Path abs_path = fs->getCurrentPath().evalNative(path);
        auto file = fs->getRoot().openFile(abs_path, kj::WriteMode::MODIFY);

        // Overwrite the magic number with null bytes.
        file->write(0, {0, 0, 0, 0, 0, 0, 0, 0});
    }

    auto rt = load_from_path(path.c_str());
    CHECK_UNARY_FALSE(rt.v.has_value());
    CHECK_UNARY_FALSE(rt.errors.empty());
}

TEST_CASE("Ensure that loading a file with corrupted data returns an error and no document.") {
    auto doc = default_doc();
    auto metadata = Metadata { .ticks_per_row = 12 };
    auto path = "document-packed"s + MODULE_EXT;

    REQUIRE_UNARY(!save_to_path(doc, metadata, path.c_str()));

    {
        kj::Own<kj::Filesystem> fs = kj::newDiskFilesystem();
        kj::Path abs_path = fs->getCurrentPath().evalNative(path);
        auto file = fs->getRoot().openFile(abs_path, kj::WriteMode::MODIFY);

        // Overwrite the first few bytes of the message.
        file->write(8, {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff});
    }

    auto rt = load_from_path(path.c_str());
    CHECK_UNARY_FALSE(rt.v.has_value());
    CHECK_UNARY_FALSE(rt.errors.empty());
}

// TODO test file backup system and/or atomic overwrites.
// probably can't test for sync() though, except through subclasses.

}

#endif
