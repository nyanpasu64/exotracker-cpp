#include "doc/validate.h"
#include "serialize.h"
#include "serialize/document.capnp.h"
#include "chip_kinds.h"
#include "util/copy_move.h"
#include "util/expr.h"
#include "util/release_assert.h"

#include <fmt/core.h>
#include <fmt/compile.h>
#include <kj/common.h>
#include <kj/function.h>
#include <kj/memory.h>
#include <kj/filesystem.h>
#include <capnp/message.h>
#include <capnp/serialize-packed.h>

#include <iterator>  // std::back_inserter
#include <limits>  // std::numeric_limits
#include <optional>
#include <string_view>

namespace serialize {

/// gen stands for autogenerated.
namespace gen = generated;
using namespace doc;
using chip_common::MAX_NCHIP;

/// Cap'n Proto uses 8-byte (64-bit) words.
static constexpr size_t BYTES_PER_WORD = 8;

/// The recommended serializer is MallocMessageBuilder.
/// When a message overflows the initial malloc'd buffer, MallocMessageBuilder
/// splits up messages into segments rather than growing the buffer.
/// I dislike this because the resulting files are more complex to process.
/// To prevent this from happening, allocate a very large buffer.
static constexpr size_t INITIAL_SIZE_BYTES = 1024 * 1024;

/// I thought mimicking &mut was a good idea. I ended up not applying it consistently.
#define MUT

/// All serialize-inner-type functions have internal linkage.
namespace {

using uint = unsigned int;
using std::optional;
using std::tuple;
using std::vector;

// During deserialization, not all values listed in the schema may be present.
// I don't know what happens when I dereference a missing "pointer type",
// but it probably won't segfault/UB in capnp, just return a "zero value".
// (flatbuffers returns a pointer, which I think is nullable and unsafe to dereference.)
//
// Missing-field handling bugs will likely never be caught during testing,
// since missing values never occur in files generated in any past program version,
// only in future versions where I omit old deprecated fields.
//
// I think it's safe to handle removing fields on a case-by-case basis,
// where every time I deprecate a field I manually evaluate its impact
// on past program versions, and pick whether to remove or write placeholder data, etc.
// As for malicious files, capnp is probably memory-safe
// (whereas flatbuffers returning raw pointers does not inspire confidence).

template<typename T>
inline kj::ArrayPtr<T const> array_ptr(std::vector<T> const& vec) {
    return kj::ArrayPtr<T const>(vec.data(), vec.size());
}

template<typename T, size_t N>
inline kj::ArrayPtr<T const> array_ptr(gsl::span<T, N> span) {
    return kj::ArrayPtr<T const>(span.data(), span.size());
}

template<typename T>
inline gsl::span<T const> span(std::vector<T> const& vec) {
    return gsl::span<T const>(vec.data(), vec.size());
}

template<typename T, size_t N>
inline gsl::span<T const> span(std::array<T, N> const& arr) {
    return gsl::span<T const>(arr.data(), arr.size());
}

/// Finds the length to which you can truncate the array
/// while keeping all non-nullopt elements.
template<typename T>
inline size_t leading_size(gsl::span<optional<T> const> data) {
    for (size_t i = data.size(); i--; ) {
        if (data[i].has_value()) {
            return i + 1;
        }
    }
    return 0;
}

template<typename Element, typename ListBuilder, typename F>
inline void serialize_all(
    gsl::span<Element const> items, ListBuilder gen_items, F func
) {
    uint num_to_write = gen_items.size();
    release_assert_equal(num_to_write, items.size());

    for (uint i = 0; i < num_to_write; i++) {
        func(items[i], MUT gen_items[i]);
    }
}

// gen::T::Builder is small and can be passed by value (akin to reborrowing).

void serialize_sequencer_options(
    SequencerOptions const& seq_options, gen::SequencerOptions::Builder gen_seq_options
) {
    gen_seq_options.setTargetTempo(seq_options.target_tempo);
    gen_seq_options.setSpcTimerPeriod(seq_options.spc_timer_period);
    gen_seq_options.setTicksPerBeat(seq_options.ticks_per_beat);
}

void serialize_sample(
    MaybeSample const& sample, gen::MaybeSample::Builder gen_maybe_sample
) {
    if (sample) {
        auto gen_sample = gen_maybe_sample.initSome();
        gen_sample.setName(sample->name);
        gen_sample.setBrr(array_ptr(sample->brr));
        gen_sample.setLoopByte(sample->loop_byte);
        {
            SampleTuning const& tuning = sample->tuning;
            auto gen_tuning = gen_sample.initTuning();

            gen_tuning.setSampleRate(tuning.sample_rate);
            gen_tuning.setRootKey(tuning.root_key);
            gen_tuning.setDetuneCents(tuning.detune_cents);
        }
    }
}

void serialize_samples(Samples const& samples_, gen::Document::Builder gen_doc) {
    auto samples = samples_.dyn_span();
    release_assert_equal(samples.size(), MAX_SAMPLES);

    auto num_samples = (uint) leading_size(samples);
    samples = samples.subspan(0, num_samples);
    serialize_all(samples, gen_doc.initSamples(num_samples), serialize_sample);
}

void serialize_instrument(
    MaybeInstrument const& instr, gen::MaybeInstrument::Builder gen_maybe_instr
) {
    if (instr) {
        auto gen_instr = gen_maybe_instr.initSome();
        // @1
        gen_instr.setName(instr->name);

        // @2 MaybeInstrument::keysplit
        {
            auto serialize_patch = [](
                InstrumentPatch const& patch,
                gen::InstrumentPatch::Builder gen_patch)
            {
                gen_patch.setMinNote(patch.min_note);
                gen_patch.setSampleIdx(patch.sample_idx);

                auto gen_adsr = gen_patch.initAdsr();
                Adsr const& adsr = patch.adsr;

                gen_adsr.setAttack(adsr.attack_rate);
                gen_adsr.setDecay(adsr.decay_rate);
                gen_adsr.setSustain(adsr.sustain_level);
                gen_adsr.setRelease(adsr.decay_2);
            };

            auto num_patches = instr->keysplit.size();
            release_assert(num_patches <= MAX_KEYSPLITS);
            serialize_all(
                span(instr->keysplit),
                gen_instr.initKeysplit((uint) num_patches),
                serialize_patch);
        }
    }
}

void serialize_instruments(
    Instruments const& instruments_, gen::Document::Builder gen_doc
) {
    auto instruments = instruments_.dyn_span();
    release_assert_equal(instruments.size(), MAX_INSTRUMENTS);

    auto num_instr = (uint) leading_size(instruments);
    instruments = instruments.subspan(0, num_instr);
    serialize_all(
        instruments,
        gen_doc.initInstruments(num_instr),
        serialize_instrument);
}

void serialize_chips(ChipList const& chips, gen::Document::Builder gen_doc) {
    auto num_chips = (uint) chips.size();
    auto gen_chips = gen_doc.initChips(num_chips);

    // so close, yet so far, to getting a reusable abstraction.
    for (uint i = 0; i < num_chips; i++) {
        gen_chips.set(i, EXPR(switch (chips[i]) {
            case ChipKind::Spc700: return gen::ChipKind::SPC700;
            default:
                assert(false && "Unrecognized ChipKind when serializing document");
                return gen::ChipKind::UNKNOWN;
        }));
    }
}

void serialize_chip_channel_settings(
    ChipChannelSettings const& cc_settings, gen::Document::Builder gen_doc
) {
    // We've already checked that this size is bounded.
    auto num_chips = (uint) cc_settings.size();
    auto gen_cc_settings = gen_doc.initChipChannelSettings(num_chips);

    for (uint chip = 0; chip < num_chips; chip++) {
        auto const& chan_settings = cc_settings[chip];

        auto num_channels = chan_settings.size();
        release_assert(num_channels <= chip_common::MAX_NCHAN_PER_CHIP);
        auto gen_chan_to_settings = gen_cc_settings.init(chip, (uint) num_channels);

        for (uint chan = 0; chan < num_channels; chan++) {
            ChannelSettings const& settings = chan_settings[chan];
            auto gen_settings = gen_chan_to_settings[chan];

            gen_settings.setNEffectCol(settings.n_effect_col);
        }
    }
}

void serialize_event(
    TimedRowEvent const& event, gen::TimedRowEvent::Builder gen_event
) {
    gen_event.setAnchorBeatNum(event.anchor_beat.numerator());
    gen_event.setAnchorBeatDen(event.anchor_beat.denominator());

    RowEvent const& v = event.v;
    if (v.note) {
        gen_event.getNote().setSome(v.note->value);
    }
    if (v.instr) {
        gen_event.getInstr().setSome(*v.instr);
    }
    if (v.volume) {
        gen_event.getVolume().setSome(*v.volume);
    }

    // TODO only serialize visible effect columns, based on ChipChannelSettings
    auto effects = span(v.effects);
    // v.effects is a fixed-size array span, this is guaranteed to not truncate.
    auto num_effects = (uint) leading_size(effects);
    if (num_effects) {
        serialize_all(effects, gen_event.initEffects(num_effects), [](
            MaybeEffect const& effect, gen::MaybeEffect::Builder gen_effect
        ) {
            if (effect) {
                gen_effect.setName0((uint8_t) effect->name[0]);
                gen_effect.setName1((uint8_t) effect->name[1]);
                gen_effect.setValue(effect->value);
            }
        });
    }
}

void serialize_pattern(Pattern const& pattern, gen::Pattern::Builder gen_pattern) {
    TimedEventsRef events = span(pattern.events);
    auto num_events = events.size();
    release_assert(num_events <= MAX_EVENTS_PER_PATTERN);

    serialize_all(events, gen_pattern.initEvents((uint) num_events), serialize_event);

    gen_pattern.setLoopLength(pattern.loop_length);
}

void serialize_timeline_block(
    TimelineBlock const& block, gen::TimelineBlock::Builder gen_block
) {
    gen_block.setBeginTime(block.begin_time);
    gen_block.setEndTime(block.end_time);
    serialize_pattern(block.pattern, gen_block.initPattern());
}

void serialize_timeline_cell(
    TimelineCell const& timeline_cell, gen::TimelineCell::Builder gen_timeline_cell
) {
    gsl::span<TimelineBlock const> raw_blocks = timeline_cell._raw_blocks;
    release_assert(raw_blocks.size() <= MAX_BLOCKS_PER_CELL);
    auto num_blocks = (uint) raw_blocks.size();

    serialize_all(
        raw_blocks, gen_timeline_cell.initBlocks(num_blocks), serialize_timeline_block
    );
}

void serialize_chip_channel_cells(
    ChipChannelCells const& cc_cells, gen::TimelineItem::Builder gen_item
) {
    auto num_chips = (uint) cc_cells.size();
    auto gen_cc_cells = gen_item.initChipChannelCells(num_chips);

    for (uint chip = 0; chip < num_chips; chip++) {
        auto const& channel_cells = cc_cells[chip];

        auto num_channels = channel_cells.size();
        release_assert(num_channels <= chip_common::MAX_NCHAN_PER_CHIP);
        auto gen_channel_cells = gen_cc_cells.init(chip, (uint) num_channels);

        for (uint chan = 0; chan < num_channels; chan++) {
            TimelineCell const& timeline_cell = channel_cells[chan];
            auto gen_timeline_cell = gen_channel_cells[chan];

            serialize_timeline_cell(timeline_cell, MUT gen_timeline_cell);
        }
    }
}

void serialize_timeline_item(
    TimelineFrame const& item, gen::TimelineItem::Builder gen_item
) {
    FractionInt num = item.nbeats.numerator();
    FractionInt den = item.nbeats.denominator();
    release_assert(num > 0);
    release_assert(den > 0);

    gen_item.setNbeatsNum((uint32_t) num);
    gen_item.setNbeatsDen((uint32_t) den);
    serialize_chip_channel_cells(item.chip_channel_cells, gen_item);
}

void serialize_timeline(Timeline const& timeline_, gen::Document::Builder gen_doc) {
    auto timeline = span(timeline_);
    release_assert(timeline.size() <= MAX_TIMELINE_FRAMES);
    auto num_items = (uint) timeline.size();

    serialize_all(timeline, gen_doc.initTimeline(num_items), serialize_timeline_item);
}

using ::capnp::MallocMessageBuilder;

/// Function called on a serialized document.
/// For example, you can pass in a lambda that writes a serialized document to disk
/// with a specified filename.
using BuilderCallback = kj::FunctionParam<void(MallocMessageBuilder &)>;

void serialize_impl(
    Document const& doc, Metadata metadata, BuilderCallback callback
) {
    auto builder = MallocMessageBuilder(INITIAL_SIZE_BYTES / BYTES_PER_WORD);

    auto gen_doc = builder.initRoot<gen::Document>();

    // In capnp's c++ api, initBar() is the only way to get a builder
    // pointing to an object already "owned" by a parent,
    // allowing you to set fields one by one.
    //
    // Initially the parent owns the &mut MessageBuilder,
    // and creating a child builder reborrows the MessageBuilder
    // and (by Rust rules) stops other messages from being built concurrently.
    // This feels a lot like C++ constructors and placement new.
    //
    // FlatBuffers feels closer to Rust factory functions.
    // In FlatBuffers, you create an object from a "global allocator", get a handle,
    // then create a parent object and move the handles into it.
    // But that has the restriction that only one object can be in the process
    // of initialization at a time... which is unpleasant.

    // @0
    gen_doc.setVersion(gen::Versions::CURRENT);

    // @1 Document::sequencerOptions
    serialize_sequencer_options(doc.sequencer_options, gen_doc.initSequencerOptions());

    // @2
    gen_doc.setFrequencyTable(array_ptr(doc.frequency_table.span()));

    // @3
    gen_doc.setAccidentalMode(EXPR(switch (doc.accidental_mode) {
        case AccidentalMode::Sharp: return gen::AccidentalMode::SHARP;
        case AccidentalMode::Flat: return gen::AccidentalMode::FLAT;
        default:
            assert(false && "Unrecognized AccidentalMode when serializing document");
            return gen::AccidentalMode(0);
    }));

    // @4
    gen_doc.setZoomLevel(metadata.zoom_level);

    // @5
    gen_doc.setEffectNameChars(doc.effect_name_chars);

    // @6 Document::samples
    serialize_samples(doc.samples, MUT gen_doc);

    // @7 Document::instruments
    serialize_instruments(doc.instruments, MUT gen_doc);

    release_assert_equal(doc.chips.size(), doc.chip_channel_settings.size());
    release_assert(doc.chips.size() <= MAX_NCHIP);

    // @8 Document::chips
    serialize_chips(doc.chips, MUT gen_doc);

    // @9 Document::chipChannelSettings

    // When saving a document, we do not verify its chip/channel shape.
    // This is probably OK, since any document being saved is trusted
    // (whereas files being loaded could be corrupted/malicious).
    serialize_chip_channel_settings(doc.chip_channel_settings, MUT gen_doc);

    // @10 Document::timeline
    serialize_timeline(doc.timeline, MUT gen_doc);

    return callback(builder);
}

namespace _ {
using namespace kj;

/// Shim allowing Cap'n Proto to write to a kj::File.
class FileOutputStream final: public OutputStream {
private:
    // non-null, non-owning pointer
    File const* _file;
    size_t _cursor = 0;

public:
    FileOutputStream(File const& fileParam)
        : _file(&fileParam)
    {}

    void write(const void* buffer, size_t size) override {
        _file->write(_cursor, arrayPtr(reinterpret_cast<const byte*>(buffer), size));
        _cursor += size;
    }
};
}
using _::FileOutputStream;

void write_to_file(kj::File const& file, MallocMessageBuilder & builder) {
    file.truncate(0);
    auto stream = FileOutputStream(file);

    // Write the magic number to the front of the file.
    auto magic_number = gen::MAGIC_NUMBER.get();
    stream.write(magic_number.begin(), magic_number.size());

    capnp::writePackedMessage(stream, builder);
}

std::string_view string_view(kj::StringPtr str) {
    return std::string_view(str.begin(), str.size());
}

std::string_view format_file_type(kj::FsNode::Type type) {
    // I hope kj will *never* reorder the Type enum, append elements,
    // or construct invalid enum values.
    // The vendored kj will never change,
    // but updating capnp/kj may require changing this array.
    static std::string_view errors[] = {
        "FILE",
        "DIRECTORY",
        "SYMLINK",
        "BLOCK_DEVICE",
        "CHARACTER_DEVICE",
        "NAMED_PIPE",
        "SOCKET",
        "OTHER",
    };
    return errors[(size_t) type];
}

std::optional<std::string> save_impl(
    Document const& doc, Metadata metadata, char const* path
) {
    // TODO add https://lamarrr.github.io/STX/structstx_1_1Result.html.
    // do error messages need to be translated?

    // on Windows, while this object exists, C:/ and the working directory are locked.
    // I would *not* keep it around, despite what the docs say.
    kj::Own<kj::Filesystem> fs = kj::newDiskFilesystem();
    kj::Path abs_path = fs->getCurrentPath().evalNative(path);

    // Holds a reference to abs_path.
    kj::PathPtr parent = abs_path.parent();
    kj::PathPtr basename = abs_path.basename();

    auto dir_open = fs->getRoot().openSubdir(parent, kj::WriteMode::MODIFY);

    // If the input path is a directory, fail instead of replacing it with a file.
    // (This is a best-effort attempt, vulnerable to TOCTTOU race conditions,
    // but I don't care).
    auto maybe_metadata = dir_open->tryLstat(basename);
    KJ_IF_MAYBE(m, maybe_metadata) {
        // We replace files with new files (OK), and replace symlinks with new files
        // (bad, maybe we should resolve the symlink, but IDK if it's better than not
        // saving at all).
        // Other special file types result in a save error.
        if (m->type != kj::FsNode::Type::FILE && m->type != kj::FsNode::Type::SYMLINK) {
            return fmt::format("cannot overwrite path \"{}\", has type {}",
                string_view(abs_path.toString(true)), format_file_type(m->type)
            );
        }
    }

    // TODO add "save options" with backup toggle.
    // Pick a backup dir (.? ./Backups? ~/Documents/ExoTracker/Backups?).
    // If "backup files" is true, while the source path exists
    // (either check its existence each iteration, or lock it in place while renaming),
    // run Directory::tryTransfer() to
    // backup dir/(original name, date/time, incrementing counter)
    // with WriteMode::CREATE (do not overwrite existing backups of the same timestamp)
    // until it succeeds.

    // "The `CREATE` and `MODIFY` bits of `mode` are not enforced until commit time."
    auto tx = dir_open->replaceFile(
        basename, kj::WriteMode::CREATE | kj::WriteMode::MODIFY
    );
    kj::File const& file = tx->get();

    serialize_impl(doc, metadata, [&file](MallocMessageBuilder & builder) {
        write_to_file(file, builder);
    });

    // Directory::Replacer::commit() doesn't sync the file before renaming it.
    // Is syncing necessary? It depends.
    // https://en.wikipedia.org/wiki/Ext4#Delayed_allocation_and_potential_data_loss
    // https://unix.stackexchange.com/questions/464382/which-filesystems-require-fsync-for-crash-safety-when-replacing-an-existing-fi
    // No clue on Windows.
    file.sync();

    // See commit() doc comments for details on atomic saving.
    tx->commit();

    // Don't call dir_open.sync().
    // It's not worthwhile to fsync the parent directory on Linux
    // because we only need crash atomicity, not flushing the rename to disk.
    // And on Windows, dir_open.sync() is not possible, and throws an exception.

    return {};
}

}  // anonymous namespace

/// What encoding-related issues do we have with paths?
///
/// ## Linux: Qt/QString are fundamentally broken
///
/// Linux filenames are actually bags of raw bytes, with no fixed encoding
/// (but systems today universally store UTF-8).
///
/// QFileDialog/QFile operate on QString, which is UTF-16.
///
/// When converting a Linux filename to a QString,
/// Qt mangles the names of non-UTF-8 files
/// (at least if Linux's locale uses UTF-8 encoding, which is standard today).
/// As a result, QFileDialog/QFile can't properly open/save files with non-UTF-8 names
/// (such as Shift-JIS files extracted from Japanese ZIP files).
///
/// ## Windows: Can be made to work through WTF-8
///
/// Windows filenames (as well as QString) are defined to contain
/// "UTF-16 plus unpaired surrogates".
///
/// kj/filesystem.h accepts StringPtr, which is UTF-8 with a trailing NUL byte.
///
/// We must convert a Windows filename (aka QString) to UTF-8,
/// and kj will convert UTF-8 back to UTF-16 to call Win32 APIs.
/// Ideally, QString::toUtf8() would convert unpaired surrogates into WTF-8
/// (malformed UTF-8), then kj would convert WTF-8 back to UTF-16,
/// but it doesn't work out in practice (though it could be fixed).
/// However, this is a less important bug than Linux,
/// because no language/charset contains unpaired surrogates
/// so a user is unlikely to encounter them "in the wild"
/// (except from slicing UTF-16 strings containing emoji?)
///
/// - QString::toUtf8() indirectly calls QUtf8Functions::toUtf8(),
///   which replaces unpaired surrogates with ?.
///   This function must be replaced with a different algorithm outputting WTF-8
///   (perhaps kj::decodeUtf16()?).
///
/// - kj::PathPtr::forWin32Api() calls kj::encodeWideString()
///   (which flags unpaired surrogates as errors)...
///   then discards the error flag entirely!
///   This works for our purposes.
///
/// We use `char const*` because we convert it into kj::StringPtr,
/// which requires a null terminator, and std::string_view doesn't guarantee one.
///
/// TODO re-export kj::decodeUtf16() in public API?
/// (Ideally we'd return std::string, but that requires an extra copy.)
std::optional<std::string> save_to_path(
    doc::Document const& doc, Metadata metadata, char const* path
) {
    std::optional<std::string> out;
    auto maybe_exception = kj::runCatchingExceptions([&]() {
        out = save_impl(doc, metadata, path);
    });
    KJ_IF_MAYBE(e, maybe_exception) {
        return fmt::format("Error saving file: {}", string_view(e->getDescription()));
    }

    return out;
}

/// All deserialize-inner-type functions have internal linkage.
namespace {

using std::move;

// # Vector.

template<typename T, typename Container>
inline std::vector<T> to_owned(Container ptr) {
    std::vector<T> out;
    out.reserve(ptr.size());
    for (auto && val : ptr) {
        out.push_back(val);
    }
    return out;
}

template<typename T>
std::vector<T> with_capacity(size_t cap) {
    std::vector<T> vec;
    vec.reserve(cap);
    return vec;
}

std::string_view string_view(fmt::memory_buffer const& str) {
    return std::string_view(str.begin(), str.size());
}

std::string string(fmt::memory_buffer const& str) {
    return std::string(str.begin(), str.end());
}

// # Error handling.

using namespace doc::validate;  // validate_*

// # Loading functions
SequencerOptions load_sequencer_options(
    ErrorState & state, gen::SequencerOptions::Reader gen_seq_options
) {
    return validate_sequencer_options(SequencerOptions {
        .target_tempo = gen_seq_options.getTargetTempo(),
        .spc_timer_period = gen_seq_options.getSpcTimerPeriod(),
        .ticks_per_beat = gen_seq_options.getTicksPerBeat(),
    }, state);
}

using GenVecDouble = ::capnp::List<double, ::capnp::Kind::PRIMITIVE>::Reader;
FrequenciesOwned load_frequency_table(ErrorState & state, GenVecDouble gen_freq_table) {
    auto valid_size = truncate_frequency_table(state, gen_freq_table.size());

    FrequenciesOwned freq_table;
    for (uint i = 0; i < valid_size; i++) {
        freq_table[i] = gen_freq_table[i];
    }

    return validate_frequency_table(state, freq_table.span(), valid_size);
}

SampleTuning load_tuning(ErrorState & state, gen::SampleTuning::Reader gen_tuning) {
    return validate_tuning(state, SampleTuning {
        .sample_rate = gen_tuning.getSampleRate(),
        .root_key = gen_tuning.getRootKey(),
        .detune_cents = gen_tuning.getDetuneCents(),
    });
}

Sample load_sample(ErrorState & state, gen::MaybeSample::Some::Reader gen_sample) {
    auto prefix = ErrorPrefixer(state);

    prefix.push_literal(state, ".tuning");
    auto tuning = load_tuning(state, gen_sample.getTuning());
    prefix.pop(state);

    return validate_sample(state, Sample {
        .name = gen_sample.getName(),
        .brr = to_owned<uint8_t>(gen_sample.getBrr()),
        .loop_byte = gen_sample.getLoopByte(),
        .tuning = move(tuning),
    });
}

using GenSamples = ::capnp::List< ::serialize::generated::MaybeSample, ::capnp::Kind::STRUCT>::Reader;
Samples load_samples(ErrorState & state, GenSamples gen_samples) {
    Samples samples;
    auto prefix = ErrorPrefixer(state);

    auto valid_size = truncate_samples(state, gen_samples.size());
    for (uint i = 0; i < valid_size; i++) {
        if (gen_samples[i].isSome()) {
            prefix.push(state, "[{}]", i);
            samples[i] = load_sample(state, gen_samples[i].getSome());
            prefix.pop(state);
        }
    }
    return samples;
}

InstrumentPatch load_patch(ErrorState & state, gen::InstrumentPatch::Reader gen_patch) {
    auto gen_adsr = gen_patch.getAdsr();

    return validate_patch(state, InstrumentPatch {
        .min_note = gen_patch.getMinNote(),
        .sample_idx = gen_patch.getSampleIdx(),
        .adsr = Adsr {
            gen_adsr.getAttack(),
            gen_adsr.getDecay(),
            gen_adsr.getSustain(),
            gen_adsr.getRelease(),
        },
    });
}

Instrument load_instrument(
    ErrorState & state, gen::MaybeInstrument::Some::Reader gen_instr
) {
    auto prefix = ErrorPrefixer(state);

    std::string name = gen_instr.getName();
    auto gen_keysplit = gen_instr.getKeysplit();

    auto num_keysplits = truncate_keysplits(state, gen_keysplit.size());

    std::vector<InstrumentPatch> keysplit;
    keysplit.reserve(num_keysplits);
    for (uint k = 0; k < num_keysplits; k++) {
        prefix.push(state, ".keysplit[{}]", k);
        keysplit.push_back(load_patch(state, gen_keysplit[k]));
        prefix.pop(state);
    }

    return Instrument {
        .name = move(name),
        .keysplit = move(keysplit),
    };
}

using GenInstruments = ::capnp::List< ::serialize::generated::MaybeInstrument, ::capnp::Kind::STRUCT>::Reader;
Instruments load_instruments(ErrorState & state, GenInstruments gen_instruments) {
    Instruments instruments;
    auto prefix = ErrorPrefixer(state);

    auto n_instr = truncate_instruments(state, gen_instruments.size());
    for (uint i = 0; i < n_instr; i++) {
        if (gen_instruments[i].isSome()) {
            prefix.push(state, "[{}]", i);
            instruments[i] = load_instrument(state, gen_instruments[i].getSome());
            prefix.pop(state);
        }
    }
    return instruments;
}

using GenChips = ::capnp::List< ::serialize::generated::ChipKind, ::capnp::Kind::ENUM>::Reader;
optional<ChipList> load_chips(ErrorState & state, GenChips gen_chips) {
    auto err = ErrorFrame(state);

    auto maybe_nchip = validate_nchip(state, gen_chips.size());
    if (!maybe_nchip) {
        return {};
    }
    auto num_chip = *maybe_nchip;

    ChipList chips;
    chips.reserve(num_chip);

    for (uint i = 0; i < num_chip; i++) {
        auto gen_chip = gen_chips[i];
        ChipKind chip_kind;
        /*
        The code to convert from capnp ChipKind to C++ ChipKind
        is specific to Cap'n Proto (so is located in serialize.cpp).
        It does not generalize to converting from text-based formats to C++ ChipKind
        (so is not located in doc/validate.h).

        If I eventually add another binary file format using the same capnp
        ChipKind values, I may find a way to factor this conversion process out.
        (I don't know if instruments will use ChipKind or a new InstrumentKind.)
        */
        switch (gen_chip) {
        case gen::ChipKind::SPC700:
            chip_kind = ChipKind::Spc700;
            break;
        case gen::ChipKind::UNKNOWN:
            PUSH_FATAL(err, "[{}]=ChipKind::UNKNOWN, cannot load", i);
            continue;
        default:
            PUSH_FATAL(err, "[{}]={} (unknown chip kind), cannot load", i, gen_chip);
            continue;
        }

        chips.push_back(chip_kind);
    }

    if (err.has_fatal) {
        return {};
    }
    return {std::move(chips)};
}

ChannelSettings load_channel_settings(
    ErrorState & state, gen::PerChannelSettings::Reader gen_settings
) {
    return validate_channel_settings(state, ChannelSettings {
        .n_effect_col = gen_settings.getNEffectCol(),
    });
}

using GenChipChannelSettings =
    ::capnp::List< ::capnp::List< ::serialize::generated::PerChannelSettings, ::capnp::Kind::STRUCT>, ::capnp::Kind::LIST>::Reader;
optional<ChipChannelSettings> load_chip_channel_settings(
    ErrorState & state,
    GenChipChannelSettings gen_cc_settings,
    ChipMetadataRef chips_metadata)
{
    release_assert(!chips_metadata.empty());

    auto prefix = ErrorPrefixer(state);
    bool has_fatal = false;

    auto maybe_nchip = validate_nchip_matches(
        state, gen_cc_settings.size(), chips_metadata.size()
    );
    if (!maybe_nchip) {
        return {};
    }
    auto nchip = *maybe_nchip;

    ChipChannelSettings cc_settings;
    cc_settings.reserve(nchip);

    // Idea: split function into 3?
    // (will have more isolated scopes from each other, good or bad?)
    for (uint chip_idx = 0; chip_idx < nchip; chip_idx++) {
        auto gen_chan_to_settings = gen_cc_settings[chip_idx];

        auto maybe_nchan = validate_nchan_matches(
            state, gen_chan_to_settings.size(), chips_metadata, chip_idx
        );
        if (!maybe_nchan) {
            has_fatal = true;
            continue;
        }
        auto nchan = *maybe_nchan;

        std::vector<ChannelSettings> channel_to_settings;
        channel_to_settings.reserve(nchan);

        for (uint chan_idx = 0; chan_idx < nchan; chan_idx++) {
            auto gen_settings = gen_chan_to_settings[chan_idx];

            prefix.push(state, "[{}][{}]", chip_idx, chan_idx);
            channel_to_settings.push_back(load_channel_settings(state, gen_settings));
            prefix.pop(state);
        }

        cc_settings.push_back(move(channel_to_settings));
    }

    if (has_fatal) {
        return {};
    } else {
        return {move(cc_settings)};
    }
}

MaybeEffect load_effect(
    ErrorState & state, gen::MaybeEffect::Reader gen_effect
) {
    auto gen_name_0 = gen_effect.getName0();
    auto gen_name_1 = gen_effect.getName1();

    if (gen_name_0 == 0 && gen_name_1 == 0) {
        return {};
    }
    auto gen_value = gen_effect.getValue();

    return validate_effect(
        state, Effect(EffectName{(char) gen_name_0, (char) gen_name_1}, gen_value)
    );
}

optional<TimedRowEvent> load_event(
    ErrorState & state,
    gen::TimedRowEvent::Reader gen_event,
    MaybeNonZero<uint32_t> loop_length)
{
    // TODO validate that event lies within block length? (Requires a new parameter.)
    auto prefix = ErrorPrefixer(state);

    auto maybe_anchor_beat = validate_anchor_beat(
        state, gen_event.getAnchorBeatNum(), gen_event.getAnchorBeatDen()
    );
    if (!maybe_anchor_beat) {
        return {};
    }
    auto anchor_beat = *maybe_anchor_beat;

    auto gen_note = gen_event.getNote();
    optional<Note> note;
    if (gen_note.isSome()) {
        note = Note(gen_note.getSome());
    }

    auto gen_instr = gen_event.getInstr();
    optional<InstrumentIndex> instr;
    if (gen_instr.isSome()) {
        instr = gen_instr.getSome();
    }

    auto gen_volume = gen_event.getVolume();
    optional<Volume> volume;
    if (gen_volume.isSome()) {
        volume = gen_volume.getSome();
    }

    auto gen_effects = gen_event.getEffects();
    PUSH(".v.effects");
    auto neffect = truncate_effects(state, gen_effects.size());
    POP();

    EffectList effects;
    for (uint i = 0; i < neffect; i++) {
        PUSH(".v.effects[{}]", i);
        effects[i] = load_effect(state, gen_effects[i]);
        POP();
    }

    return validate_event(
        state,
        TimedRowEvent {
            .anchor_beat = anchor_beat,
            .v = RowEvent {
                .note = note,
                .instr = instr,
                .volume = volume,
                .effects = effects,
            }
        },
        loop_length);
}

optional<Pattern> load_pattern(ErrorState & state, gen::Pattern::Reader gen_pattern) {
    auto prefix = ErrorPrefixer(state);
    bool fatal = false;

    MaybeNonZero<uint32_t> loop_length = gen_pattern.getLoopLength();

    auto gen_events = gen_pattern.getEvents();
    auto size = truncate_events(state, gen_events.size());
    auto events = with_capacity<TimedRowEvent>(size);
    for (uint i = 0; i < size; i++) {
        PUSH(".events[{}]", i);
        auto event = load_event(state, gen_events[i], loop_length);
        POP();
        if (!event) {
            fatal = true;
            continue;
        }
        events.push_back(*event);
    }

    if (fatal) {
        return {};
    }
    // If invalid events were skipped, don't bother verifying events are sorted,
    // since the error messages will contain the wrong indexes.

    // Validate events are sorted <= in time (ignoring delay effects
    // since those depend on column count).
    PUSH(".events");
    events = validate_events(state, move(events));
    POP();

    return validate_pattern(state, Pattern {
        .events = move(events),
        .loop_length = loop_length,
    });
}

optional<TimelineBlock> load_timeline_block(
    ErrorState & state, gen::TimelineBlock::Reader gen_block
) {
    auto prefix = ErrorPrefixer(state);

    int32_t begin_time = gen_block.getBeginTime();
    uint32_t end_time = gen_block.getEndTime();

    PUSH_LITERAL(".pattern");
    auto pattern = load_pattern(state, gen_block.getPattern());
    POP();

    if (!pattern) {
        return {};
    }
    return validate_timeline_block(state, TimelineBlock {
        .begin_time = begin_time,
        .end_time = end_time,
        .pattern = move(*pattern),
    });
}

optional<TimelineCell> load_timeline_cell(
    ErrorState & state, gen::TimelineCell::Reader gen_timeline_cell
) {
    auto prefix = ErrorPrefixer(state);
    bool has_fatal = false;

    auto gen_blocks = gen_timeline_cell.getBlocks();
    auto size = truncate_blocks(state, gen_blocks.size());
    auto blocks = with_capacity<TimelineBlock>(size);

    for (uint b = 0; b < size; b++) {
        // TODO ensure block start times are monotonic and blocks don't overlap.
        // TODO ensure blocks are within frame bounds. This requires a new parameter.
        PUSH(".blocks[{}]", b);
        auto block = load_timeline_block(state, gen_blocks[b]);
        POP();
        if (block) {
            blocks.push_back(*block);
        } else {
            has_fatal = true;
        }
    }

    if (has_fatal) {
        return {};
    }
    return {TimelineCell(move(blocks))};
}

using GenChipChannelCells =
    ::capnp::List< ::capnp::List< ::serialize::generated::TimelineCell,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>::Reader;
optional<ChipChannelCells> load_chip_channel_cells(
    ErrorState & state, GenChipChannelCells gen_cc_cells, ChipMetadataRef chips_metadata
) {
    auto prefix = ErrorPrefixer(state);
    bool has_fatal = false;

    auto maybe_nchip =
        validate_nchip_matches(state, gen_cc_cells.size(), chips_metadata.size());
    if (!maybe_nchip) {
        return {};
    }
    auto nchip = *maybe_nchip;

    ChipChannelCells cc_cells;
    cc_cells.reserve(nchip);
    for (uint chip_idx = 0; chip_idx < nchip; chip_idx++) {
        auto gen_channel_cells = gen_cc_cells[chip_idx];

        auto maybe_nchan = validate_nchan_matches(
            state, gen_channel_cells.size(), chips_metadata, chip_idx
        );
        if (!maybe_nchan) {
            has_fatal = true;
            continue;
        }
        auto nchan = *maybe_nchan;

        auto channel_cells = with_capacity<TimelineCell>(nchan);
        for (uint chan_idx = 0; chan_idx < nchan; chan_idx++) {
            PUSH("[{}][{}]", chip_idx, chan_idx);
            auto timeline_cell = load_timeline_cell(state, gen_channel_cells[chan_idx]);
            POP();
            if (timeline_cell) {
                channel_cells.push_back(move(*timeline_cell));
            } else {
                has_fatal = true;
            }
        }

        cc_cells.push_back(channel_cells);
    }

    if (has_fatal) {
        return {};
    }
    return {move(cc_cells)};
}

optional<TimelineFrame> load_timeline_item(
    ErrorState & state,
    gen::TimelineItem::Reader gen_item,
    ChipMetadataRef chips_metadata)
{
    auto prefix = ErrorPrefixer(state);

    auto maybe_nbeats =
        validate_frame_nbeats(state, gen_item.getNbeatsNum(), gen_item.getNbeatsDen());

    PUSH_LITERAL(".chip_channel_cells");
    auto chip_channel_cells =
        load_chip_channel_cells(state, gen_item.getChipChannelCells(), chips_metadata);
    POP();

    if (maybe_nbeats && chip_channel_cells) {
        return TimelineFrame {
            .nbeats = *maybe_nbeats,
            .chip_channel_cells = move(*chip_channel_cells),
        };
    } else {
        return {};
    }
}

using GenTimeline = ::capnp::List< ::serialize::generated::TimelineItem,  ::capnp::Kind::STRUCT>::Reader;
optional<Timeline> load_timeline(
    ErrorState & state, GenTimeline gen_timeline, ChipMetadataRef chips
) {
    auto prefix = ErrorPrefixer(state);
    bool has_fatal = false;

    auto size = truncate_timeline_frames(state, gen_timeline.size());
    Timeline timeline;
    timeline.reserve(size);

    for (uint i = 0; i < size; i++) {
        PUSH("[{}]", i);
        auto item = load_timeline_item(state, gen_timeline[i], chips);
        POP();
        if (item) {
            timeline.push_back(*item);
        } else {
            has_fatal = true;
        }
    }

    if (!has_fatal) {
        return {move(timeline)};
    } else {
        return {};
    }
}

static std::string string_to_hex(gsl::span<const uint8_t> input) {
    static char const hex_digits[] = "0123456789ABCDEF";

    std::string output;
    output.reserve(input.size() * 2);

    bool sep = false;

    for (auto c : input) {
        if (sep) {
            output.push_back(' ');
        }
        output.push_back(hex_digits[c >> 4]);
        output.push_back(hex_digits[c & 0xf]);
        sep = true;
    }

    return output;
}

/// Either throws an exception (after possibly appending to `errors`),
/// or returns a value moved from `errors` (leaving `errors` empty).
///
/// Reading a document with invalid values does not throw exceptions,
/// but only produces error/warning values.
/// Cap'n Proto throws exceptions when it reads corrupted/invalid binary data.
///
/// Exceptions are not caught at any point in this function, only by the caller, load().
/// They do not erase prior error messages,
/// but prevent further loading functions from being called.
LoadDocumentResult load_impl(kj::InputStream & stream, ErrorState & state) {
    // TODO change return type to std::optional<tuple<doc::Document, Metadata>>,
    // and unconditionally write errors by reference, rather than only upon exceptions.
    // Read the magic number from the front of the file.
    auto magic_number = gen::MAGIC_NUMBER.get();

    constexpr size_t MAGIC_SIZE = 8;
    assert(magic_number.size() == MAGIC_SIZE);

    uint8_t gen_magic_number[MAGIC_SIZE];
    stream.read(gen_magic_number, MAGIC_SIZE, MAGIC_SIZE);
    if (magic_number != gen_magic_number) {
        PUSH_ERROR(state,
            "Unrecognized file, expected leading bytes {}, got {}",
            string_to_hex(gsl::span(magic_number.begin(), magic_number.size())),
            string_to_hex(gen_magic_number));
        return LoadDocumentResult::err(move(state.err));
    }

    auto buffered = kj::BufferedInputStreamWrapper(stream);
    auto reader = capnp::PackedMessageReader(buffered);

    auto gen_doc = reader.getRoot<gen::Document>();

    auto prefix = ErrorPrefixer(state);

    uint32_t gen_version = gen_doc.getVersion();
    if (gen_version < gen::Versions::MINIMUM) {
        PUSH_WARNING(state,
            "file version {} is older than minimum supported version {}, file may not load properly",
            gen_version, gen::Versions::MINIMUM
        );
    }
    if (gen_version > gen::Versions::CURRENT) {
        PUSH_WARNING(state,
            "file version {} is newer than latest supported version {}, file may not load properly",
            gen_version, gen::Versions::CURRENT
        );
    }

    auto metadata = Metadata {
        .zoom_level = gen_doc.getZoomLevel(),
    };

    prefix.push(state, "sequencer_options");
    auto sequencer_options =
        load_sequencer_options(state, gen_doc.getSequencerOptions());
    prefix.pop(state);

    prefix.push(state, "frequency_table");
    auto frequency_table = load_frequency_table(state, gen_doc.getFrequencyTable());
    prefix.pop(state);

    auto accidental_mode = EXPR(
        auto gen_accidental_mode = gen_doc.getAccidentalMode();
        switch (gen_accidental_mode) {
        case gen::AccidentalMode::SHARP: return AccidentalMode::Sharp;
        case gen::AccidentalMode::FLAT: return AccidentalMode::Flat;
        default:
            PUSH_WARNING(state,
                "accidental_mode={} unrecognized (should be Sharp or Flat), defaulting to Sharp",
                gen_accidental_mode
            );
            return AccidentalMode::Sharp;
    });

    auto effect_name_chars =
        validate_effect_name_chars(state, gen_doc.getEffectNameChars());

    prefix.push(state, "samples");
    auto samples = load_samples(state, gen_doc.getSamples());
    prefix.pop(state);

    prefix.push(state, "instruments");
    auto instruments = load_instruments(state, gen_doc.getInstruments());
    prefix.pop(state);

    prefix.push(state, "chips");
    auto chips = load_chips(state, gen_doc.getChips());
    prefix.pop(state);

    ChipMetadatas chips_metadata;
    if (chips) {
        chips_metadata = compute_chip_metadata(*chips);
    }

    optional<ChipChannelSettings> chip_channel_settings = {};
    if (chips) {
        prefix.push(state, "chip_channel_settings");
        chip_channel_settings = load_chip_channel_settings(
            state, gen_doc.getChipChannelSettings(), chips_metadata
        );
        prefix.pop(state);
    }

    optional<Timeline> timeline = {};
    if (chips) {
        prefix.push(state, "timeline");
        timeline = load_timeline(state, gen_doc.getTimeline(), chips_metadata);
        prefix.pop(state);
    }

    if (chips && chip_channel_settings && timeline) {
        return LoadDocumentResult::ok(
            doc::DocumentCopy{
                .sequencer_options = move(sequencer_options),
                .frequency_table = move(frequency_table),
                .accidental_mode = accidental_mode,
                .effect_name_chars = effect_name_chars,
                .samples = move(samples),
                .instruments = move(instruments),
                .chips = move(*chips),
                .chip_channel_settings = move(*chip_channel_settings),
                .timeline = move(*timeline),
            },
            metadata,
            move(state.err));
    } else {
        return LoadDocumentResult::err(move(state.err));
    }
}

/// Does not throw exceptions.
LoadDocumentResult load(kj::InputStream & stream) {
    ErrorState state;
    optional<LoadDocumentResult> out;

    auto maybe_exception = kj::runCatchingExceptions([&]() {
        out = load_impl(stream, state);
    });
    KJ_IF_MAYBE(e, maybe_exception) {
        state.err.push_back(ERR_FMT(
            "Error loading file, at point {}: {}",
            string_view(state.msg), string_view(e->getDescription())
        ));
        return LoadDocumentResult::err(move(state.err));
    }

    release_assert(out);
    return move(*out);
}

namespace _ {
using namespace kj;

/// Shim allowing Cap'n Proto to read from a kj::ReadableFile.
class FileInputStream final : public kj::InputStream {
private:
    // non-null, non-owning pointer
    ReadableFile const* _file;
    size_t _cursor = 0;

public:
    FileInputStream(ReadableFile const& file)
        : _file(&file)
    {}

    size_t tryRead(void* buffer, size_t /*minBytes*/, size_t maxBytes) override {
        // Implements InputStream::tryRead(),
        // which "may return fewer than minBytes on EOF",
        // by delegating to ReadableFile::read(),
        // which returns "less than `buffer.size()`... when EOF occurs mid-buffer."
        auto bytes_read = _file->read(_cursor, ArrayPtr((byte *) buffer, maxBytes));
        _cursor += bytes_read;
        return bytes_read;
    }
};
}
using _::FileInputStream;

}  // anonymous namespace

LoadDocumentResult load_from_path(char const* path) {
    // On Windows, while a kj::Filesystem exists,
    // C:/ and the initial working directory are locked,
    // making it undesirable to keep it around for long periods of time...
    //
    // Though perhaps it doesn't matter as much,
    // since all processes lock the current working directory
    // (though kj::Filesystem continues locking the initial directory
    // even after the process changes working directories).
    kj::Own<kj::Filesystem> fs = kj::newDiskFilesystem();
    kj::Path abs_path = fs->getCurrentPath().evalNative(path);

    // `tryOpenFile()` returns null if the path doesn't exist. Other errors still throw exceptions.
    // For KJ exception guidance, see
    // https://github.com/capnproto/capnproto/blob/master/kjdoc/tour.md#throwing-and-catching-exceptions .
    kj::Own<const kj::ReadableFile> file;
    auto maybe_exception = kj::runCatchingExceptions([&]() {
        file = fs->getRoot().openFile(abs_path);
    });
    KJ_IF_MAYBE(e, maybe_exception) {
        auto description = e->getDescription();
        return LoadDocumentResult::err({
            ERR_FMT("Error opening file {}: {}", path, string_view(description))
        });
    }

    auto stream = FileInputStream(*file);
    return load(stream);
}

LoadDocumentResult LoadDocumentResult::ok(
    doc::Document doc, Metadata metadata, Errors errors
) {
    return LoadDocumentResult(tuple(move(doc), metadata), move(errors));
}

LoadDocumentResult LoadDocumentResult::err(Errors errors) {
    assert(!errors.empty());
    if (errors.size() == 0) {
        errors.push_back(Error {
            .type = ErrorType::Error,
            .description = "Load failed, no error message (this should never happen, please report a bug!)",
        });
    }
    return LoadDocumentResult({}, move(errors));
}

LoadDocumentResult::LoadDocumentResult(
    optional<tuple<doc::Document, Metadata>> v_, Errors errors_
)
    : v(move(v_))
    , errors(move(errors_))
{
    // this should never happen, it's redundant with ok()/err().
    if (!v.has_value()) {
        assert(!errors.empty());
    }
}


}  /// namespace serialize

#ifdef UNITTEST

#include "sample_docs.h"

#include <doctest.h>

#include <fstream>

namespace serialize {

static Document default_doc() {
    return DocumentCopy(sample_docs::DOCUMENTS.at(sample_docs::DEFAULT_DOC));
}

using namespace std::string_literals;

TEST_CASE("Serialize into memory.") {
    auto d = default_doc();

    serialize_impl(d, Metadata { .zoom_level = 4 }, [](MallocMessageBuilder & builder) {

        auto arr = capnp::messageToFlatArray(builder);
        // borrows from arr
        auto buf = arr.asChars();
        (void) buf;
    });
}

TEST_CASE("Ensure that opening a nonexistent path returns an error.") {
    auto path = "file not found i swear"s + MODULE_EXT;
    auto rt = load_from_path(path.c_str());
    CHECK_UNARY_FALSE(rt.v.has_value());
    CHECK_UNARY_FALSE(rt.errors.empty());
}

TEST_CASE("Ensure that round-tripping to file works.") {
    auto doc = default_doc();
    auto metadata = Metadata { .zoom_level = 4 };
    auto path = "document-packed"s + MODULE_EXT;

    REQUIRE_UNARY(!save_to_path(doc, metadata, path.c_str()));

    auto rt = load_from_path(path.c_str());
    CHECK_UNARY(rt.errors.empty());

    REQUIRE_UNARY(rt.v.has_value());
    auto & [rt_doc, rt_metadata] = *rt.v;
    CHECK_EQ(rt_doc, doc);
    CHECK_EQ(rt_metadata, metadata);
}

// TODO add save_to_path() optional error message,
// for saving to an invalid/nonwritable path.

TEST_CASE("Ensure that loading a file with corrupted headers returns an error and no document.") {
    auto doc = default_doc();
    auto metadata = Metadata { .zoom_level = 4 };
    auto path = "document-packed"s + MODULE_EXT;

    REQUIRE_UNARY(!save_to_path(doc, metadata, path.c_str()));

    {
        kj::Own<kj::Filesystem> fs = kj::newDiskFilesystem();
        kj::Path abs_path = fs->getCurrentPath().evalNative(path);
        auto file = fs->getRoot().openFile(abs_path, kj::WriteMode::MODIFY);

        // Overwrite the magic number with null bytes.
        file->write(0, {0, 0, 0, 0, 0, 0, 0, 0});
    }

    auto rt = load_from_path(path.c_str());
    CHECK_UNARY_FALSE(rt.v.has_value());
    CHECK_UNARY_FALSE(rt.errors.empty());
}

TEST_CASE("Ensure that loading a file with corrupted data returns an error and no document.") {
    auto doc = default_doc();
    auto metadata = Metadata { .zoom_level = 4 };
    auto path = "document-packed"s + MODULE_EXT;

    REQUIRE_UNARY(!save_to_path(doc, metadata, path.c_str()));

    {
        kj::Own<kj::Filesystem> fs = kj::newDiskFilesystem();
        kj::Path abs_path = fs->getCurrentPath().evalNative(path);
        auto file = fs->getRoot().openFile(abs_path, kj::WriteMode::MODIFY);

        // Overwrite the first few bytes of the message.
        file->write(8, {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff});
    }

    auto rt = load_from_path(path.c_str());
    CHECK_UNARY_FALSE(rt.v.has_value());
    CHECK_UNARY_FALSE(rt.errors.empty());
}

// TODO test file backup system and/or atomic overwrites.
// probably can't test for sync() though, except through subclasses.

}

#endif
